<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WildLogic HQ</title>
    <link rel="icon" type="image/png" href="data:image/png;base64,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">
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css" rel="stylesheet">
    
    <!-- Highcharts -->
    <script src="https://code.highcharts.com/stock/highstock.js"></script>
    <script src="https://code.highcharts.com/highcharts-more.js"></script>
    
    <style>
        :root {
            --bg-dark: #1a1a1b;
            --bg-card: #2a2a2b;
            --bg-input: #3e3e40;
            --text-primary: #E0E0E3;
            --text-muted: #888;
            --accent-green: #4ade80;
            --accent-blue: #1C86EE;
            --accent-red: #dc2626;
            --accent-gold: #ffd700;
        }
        
        body {
            background-color: var(--bg-dark);
            color: var(--text-primary);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
        }
        
        /* Navbar */
        .navbar {
            background-color: var(--bg-card) !important;
            position: sticky;
            top: 0;
            z-index: 1020;
            height: 56px;
        }
        
        .navbar .container-fluid {
            position: relative;
        }
        
        #mainTabs {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .navbar-brand {
            font-size: 1.4rem;
            font-weight: bold;
            color: var(--accent-gold) !important;
        }
        
        .nav-tabs { border-bottom: none; }
        
        .nav-tabs .nav-link {
            color: var(--text-muted);
            border: none;
            padding: 1rem 1.5rem;
            font-weight: 500;
        }
        
        .nav-tabs .nav-link:hover { color: var(--text-primary); }
        
        .nav-tabs .nav-link.active {
            color: var(--accent-green);
            background: transparent;
            border-bottom: 3px solid var(--accent-green);
        }
        
        /* Filter bar (below navbar) */
        .filter-bar {
            position: sticky;
            top: 56px; /* navbar height */
            z-index: 1010;
            background-color: var(--bg-card);
            padding: 10px 0;
            border-bottom: 1px solid #444;
        }
        
        /* Cards */
        .card {
            background-color: var(--bg-card);
            border: none;
            border-radius: 8px;
        }
        
        .card-body {
            padding: 20px;
        }
        
        .card-header {
            background-color: transparent;
            border-bottom: 1px solid #444;
            font-weight: 600;
        }
        
        /* Forms */
        .form-control, .form-select {
            background-color: var(--bg-input);
            border: 1px solid #555;
            color: var(--text-primary);
        }
        
        .form-control:disabled, .form-select:disabled {
            background-color: var(--bg-input);
            border-color: #444;
            color: var(--text-muted);
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .form-control:focus, .form-select:focus {
            background-color: var(--bg-input);
            border-color: var(--accent-green);
            color: var(--text-primary);
            box-shadow: 0 0 0 0.2rem rgba(74, 222, 128, 0.25);
        }
        
        .form-select option { background-color: var(--bg-input); }
        
        /* Buttons */
        .btn-success { background-color: var(--accent-green); border-color: var(--accent-green); color: #000; }
        .btn-success:hover { background-color: #22c55e; border-color: #22c55e; color: #000; }
        .btn-outline-success { border-color: var(--accent-green); color: var(--accent-green); }
        .btn-outline-success:hover { background-color: var(--accent-green); color: #000; }
        .btn-outline-secondary { border-color: #666; color: var(--text-muted); }
        .btn-outline-secondary:hover { background-color: var(--bg-input); color: var(--text-primary); }
        .btn-primary { background-color: var(--accent-blue); border-color: var(--accent-blue); }
        .btn-danger { background-color: var(--accent-red); border-color: var(--accent-red); }
        .btn-warning { background-color: #f59e0b; border-color: #f59e0b; color: #000; }
        
        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        
        .spinner-border { width: 3rem; height: 3rem; }
        
        /* Login Section */
        #hqGate {
            min-height: calc(100vh - 70px);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .login-card { max-width: 400px; width: 100%; }
        
        /* Grid View */
        .photo-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 15px;
        }
        
        .grid-item {
            position: relative;
            background: var(--bg-input);
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            border: 3px solid transparent;
        }
        
        .grid-item:hover { transform: scale(1.02); box-shadow: 0 4px 15px rgba(0,0,0,0.4); }
        .grid-item.selected { border-color: var(--accent-green); }
        
        .grid-item-checkbox {
            position: absolute;
            top: 8px; left: 8px;
            width: 26px; height: 26px;
            background: rgba(0,0,0,0.6);
            border: 2px solid #fff;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 16px;
            z-index: 10;
        }
        
        .grid-item.selected .grid-item-checkbox { background: var(--accent-green); border-color: var(--accent-green); }
        .grid-item-img { width: 100%; height: 200px; object-fit: cover; }
        
        .grid-zoom-overlay {
            position: absolute;
            bottom: 60px; left: 0; right: 0;
            height: 40px;
            background: linear-gradient(transparent, rgba(0,0,0,0.7));
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 8px;
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            opacity: 0;
            cursor: pointer;
        }
        
        .grid-item:hover .grid-zoom-overlay { opacity: 1; }
        
        .grid-item-info { padding: 8px 10px; font-size: 12px; color: var(--text-muted); }
        .grid-item-info .camera { color: var(--text-primary); font-weight: bold; margin-bottom: 3px; }
        .grid-item-info .tag { color: var(--accent-gold); }
        .grid-item-info .gallery { color: var(--accent-green); }
        .grid-item-info .gallery-icon { width: 16px; height: 16px; vertical-align: middle; margin-right: 2px; }
        
        /* Zoom Modal */
        .zoom-modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            cursor: default;
        }
        
        /* Gallery modal on top of zoom modal */
        #galleryModal, #bulkGalleryModal, #rapidFireModal {
            z-index: 2050 !important;
        }
        #galleryModal + .modal-backdrop, #bulkGalleryModal + .modal-backdrop, #rapidFireModal + .modal-backdrop {
            z-index: 2040 !important;
        }
        
        /* Lighter backdrop when opened from zoom modal (65% transparent) */
        .modal-backdrop.fade.show.gallery-from-zoom {
            opacity: 0.35 !important;
            background-color: rgba(0,0,0,0.35) !important;
        }
        
        /* Transparent modal content when opened from zoom */
        #galleryModal.from-zoom .modal-content {
            background: rgba(30, 30, 30, 0.75) !important;
            backdrop-filter: blur(5px);
        }
        
        /* Transparent modal content for bulk gallery */
        #bulkGalleryModal .modal-content {
            background: rgba(30, 30, 30, 0.75) !important;
            backdrop-filter: blur(5px);
        }
        
        .zoom-modal-container {
            position: relative;
            background: var(--bg-card);
            border-radius: 8px;
            padding: 10px;
            cursor: default;
        }
        
        /* Quick Tag Navigation Zones */
        .zoom-image-wrapper {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            border-radius: 8px 8px 0 0;
            overflow: hidden;
        }
        
        .zoom-modal-img {
            width: 960px;
            height: 720px;
            object-fit: contain;
        }
        
        .zoom-nav-zone {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 15%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
        }
        
        .zoom-nav-zone:hover {
            opacity: 1;
        }
        
        .zoom-nav-zone.left {
            left: 0;
            background: linear-gradient(to right, rgba(0,0,0,0.4), transparent);
            padding-left: 10px;
        }
        
        .zoom-nav-zone.right {
            right: 0;
            background: linear-gradient(to left, rgba(0,0,0,0.4), transparent);
            padding-right: 10px;
        }
        
        .zoom-nav-zone.disabled {
            pointer-events: none;
            opacity: 0 !important;
        }
        
        .zoom-nav-arrow {
            color: white;
            font-size: 48px;
            font-weight: 300;
            text-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }
        
        /* Quick Tag Info Panel */
        .zoom-info {
            padding: 6px 15px 4px 15px;
            background: var(--bg-card);
            border-top: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        
        .zoom-info-text {
            flex: 1;
        }
        
        .zoom-info .info-line {
            margin-bottom: 4px;
            font-size: 13px;
            white-space: nowrap;
        }
        
        .zoom-info .info-label {
            color: var(--text-muted);
        }
        
        .zoom-info .info-value {
            color: var(--text-primary);
            font-weight: 500;
        }
        
        .zoom-info .info-name {
            color: var(--accent-green);
            font-weight: 500;
        }
        
        .zoom-info .info-sep {
            color: var(--text-muted);
            margin: 0 6px;
        }
        
        /* Quick Tag Action Buttons - 3 Column Layout */
        .zoom-actions-wrapper {
            display: flex;
            padding: 4px 15px 12px 15px;
            background: var(--bg-card);
        }
        
        .zoom-left-section {
            flex: 1;
            display: flex;
            align-items: flex-end;
        }
        
        .zoom-actions {
            flex: 0 0 auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }
        
        .zoom-right-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: flex-end;
            gap: 8px;
        }
        
        .zoom-download-btn {
            padding: 8px 16px;
            border: 1px solid var(--accent-blue);
            border-radius: 20px;
            background: transparent;
            color: var(--accent-blue);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .zoom-download-btn:hover {
            background: var(--accent-blue);
            color: #fff;
        }
        
        .zoom-gallery-btn {
            padding: 8px 16px;
            border: 1px solid var(--accent-green);
            border-radius: 20px;
            background: transparent;
            color: var(--accent-green);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .zoom-gallery-btn:hover {
            background: var(--accent-green);
            color: #fff;
        }
        
        .zoom-gallery-btn.active {
            background: var(--accent-green);
            color: #000;
        }
        
        .zoom-tag-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }
        
        .zoom-tag-btn {
            padding: 8px 16px;
            border: 1px solid #555;
            border-radius: 20px;
            background: var(--bg-input);
            color: var(--text-primary);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .zoom-tag-btn:hover {
            border-color: var(--accent-green);
            background: rgba(74, 222, 128, 0.1);
        }
        
        .zoom-tag-btn.active {
            border-color: var(--accent-green);
            background: var(--accent-green);
            color: #000;
        }
        
        .zoom-none-btn {
            border-color: #666;
        }
        
        .weather-field-btn {
            background: none;
            border: none;
            color: #888;
            font-size: 13px;
            cursor: pointer;
            padding: 2px 8px;
            transition: color 0.15s;
        }
        
        .weather-field-btn:hover {
            color: #aaa;
        }
        
        .weather-field-btn.active {
            color: #17a2b8;
            font-weight: 600;
        }
        
        .zoom-none-btn:hover {
            border-color: var(--accent-red);
            background: rgba(220, 38, 38, 0.1);
        }
        
        .zoom-delete-btn {
            padding: 8px 16px;
            border: 1px solid var(--accent-red);
            border-radius: 20px;
            background: transparent;
            color: var(--accent-red);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .zoom-delete-btn:hover {
            background: var(--accent-red);
            color: #fff;
        }
        
        .zoom-rapid-label {
            color: var(--text-muted);
            font-size: 13px;
            cursor: pointer;
            transition: color 0.15s;
        }
        
        .zoom-rapid-label:hover {
            color: var(--accent-red);
        }
        
        .zoom-rapid-label.active {
            color: var(--accent-red);
            font-weight: 500;
        }
        
        .zoom-delete-section {
            display: flex;
            align-items: center;
            align-self: flex-end;
        }
        
        /* Quick Tag Progress Bar */
        .zoom-progress-wrapper {
            padding: 0;
            background: var(--bg-card);
            overflow: hidden;
        }
        
        .zoom-progress-wrapper .progress {
            border-radius: 0;
            height: 6px;
        }
        
        /* Flash animation on tag */
        .zoom-flash {
            animation: zoom-flash-anim 0.3s ease-out;
        }
        
        @keyframes zoom-flash-anim {
            0% { box-shadow: inset 0 0 0 3px var(--accent-green); }
            100% { box-shadow: inset 0 0 0 0 var(--accent-green); }
        }
        
        /* Progress bar */
        .progress { height: 6px; background-color: var(--bg-input); }
        .progress-bar { background-color: var(--accent-green); }
        
        /* Sidebar */
        .grid-sidebar { display: flex; flex-direction: column; gap: 8px; min-width: 160px; }
        .grid-selected-count { color: var(--accent-green); font-weight: bold; font-size: 14px; margin-bottom: 5px; }
        
        /* Dashboard */
        #chart_main { height: 500px; background: var(--bg-card); border-radius: 8px; overflow: visible; }
        #chart_polar { width: 450px; height: 450px; }
        #chart_weather { width: 100%; height: 380px; }
        #chart_forecast { height: 300px; }
        #chart_prediction { height: 300px; }
        
        .tooltip-panel {
            background: var(--bg-dark);
            border-radius: 8px;
            padding: 15px;
            min-height: 500px;
            max-height: 500px;
            overflow: hidden;
        }
        
        .tooltip-panel img {
            width: 100%;
            height: auto;
            border-radius: 4px;
            margin-bottom: 8px;
            display: block;
        }
        
        .tooltip-panel .info-line {
            margin-bottom: 4px;
            font-size: 13px;
            white-space: nowrap;
        }
        
        .tooltip-panel .info-label {
            color: var(--text-muted);
        }
        
        .tooltip-panel .info-value {
            color: var(--text-primary);
            font-weight: 500;
        }
        
        .tooltip-panel .info-name {
            color: var(--accent-green);
            font-weight: 500;
        }
        
        .tooltip-panel .info-sep {
            color: var(--text-muted);
            margin: 0 6px;
        }
        
        /* Sync Status Bar */
        #syncStatus {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--bg-card);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 13px;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        #syncStatus.syncing {
            border-color: var(--accent-blue);
        }
        
        #syncStatus.complete {
            border-color: var(--accent-green);
        }
        
        #syncStatus.error {
            border-color: var(--accent-red);
        }
        
        #syncStatus i {
            margin-right: 8px;
        }
    </style>
</head>
<body>

<!-- Loading Overlay -->
<div class="loading-overlay" id="loadingOverlay" style="display: none;">
    <img src="data:image/gif;base64,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" alt="Loading" style="width: 80px; height: 80px;">
    <p class="mt-3" id="loadingText">Loading...</p>
</div>

<!-- Sync Status Bar -->
<div id="syncStatus">
    <i class="bi bi-cloud-upload"></i>
    <span id="syncStatusText">Syncing...</span>
</div>

<!-- Navbar -->
<nav class="navbar navbar-expand-lg navbar-dark">
    <div class="container-fluid">
        <a class="navbar-brand" href="#">
            <i class="bi bi-broadcast-pin text-warning me-2"></i>WildLogic HQ
        </a>
        
        <ul class="nav nav-tabs" id="mainTabs" role="tablist" style="display: none;">
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="photos-tab" data-bs-toggle="tab" data-bs-target="#photosContent" type="button" role="tab">
                    <i class="bi bi-images me-1"></i>Photos
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="dashboard-tab" data-bs-toggle="tab" data-bs-target="#dashboardContent" type="button" role="tab">
                    <i class="bi bi-bar-chart-fill me-1"></i>Dashboard
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="account-tab" data-bs-toggle="tab" data-bs-target="#accountContent" type="button" role="tab">
                    <i class="bi bi-gear me-1"></i>Settings
                </button>
            </li>
        </ul>
        
        <div class="d-flex align-items-center gap-3">
            <span class="text-light small" id="cacheStatus" style="display: none; opacity: 0.5;">
                <i class="bi bi-hdd me-1"></i><span id="cacheStatusText">Local</span>
            </span>
            <span class="text-light" id="userDisplay" style="display: none; opacity: 0.5;">
                <i class="bi bi-person-circle me-1"></i><span id="userName"></span>
            </span>
            <button class="btn btn-outline-secondary btn-sm" id="logoutBtn" onclick="logout()" style="display: none;">
                <i class="bi bi-box-arrow-right"></i> Logout
            </button>
        </div>
    </div>
</nav>

<!-- Unified Filter Bar (shown after login) -->
<div class="filter-bar" id="filterBar" style="display: none;">
    <div class="container-fluid">
        <div class="d-flex justify-content-between align-items-center">
            <div class="d-flex gap-2 align-items-center flex-wrap">
                <select id="locationFilter" class="form-select form-select-sm" style="width: auto;" onchange="applyFilters()">
                    <option value="">Locations</option>
                </select>
                <select id="cameraFilter" class="form-select form-select-sm" style="width: auto;" onchange="applyFilters()">
                    <option value="">Cameras</option>
                </select>
                <select id="tagFilter" class="form-select form-select-sm" style="width: auto;" onchange="applyFilters()">
                    <option value="">Tags</option>
                    <option value="untagged">Untagged</option>
                    <option value="Buck">Buck</option>
                    <option value="Doe">Doe</option>
                    <option value="Turkey">Turkey</option>
                    <option value="Bear">Bear</option>
                    <option value="Predator">Predator</option>
                    <option value="Bird">Bird</option>
                    <option value="Human">Human</option>
                    <option value="Vehicle/ATV">Vehicle/ATV</option>
                    <option value="Other">Other</option>
                    <option value="No Animals">No Animals</option>
                </select>
                <select id="galleryFilter" class="form-select form-select-sm" style="width: auto;" onchange="applyFilters()">
                    <option value="">All Galleries</option>
                </select>
                <select id="dayNightFilter" class="form-select form-select-sm" style="width: auto;" onchange="applyFilters()">
                    <option value="">Day & Night</option>
                    <option value="day">Daytime</option>
                    <option value="night">Nighttime</option>
                </select>
                <select id="sortOrder" class="form-select form-select-sm" style="width: auto; display: none;" onchange="applyFilters()">
                    <option value="newest">Newest First</option>
                    <option value="oldest">Oldest First</option>
                </select>
                <button class="btn btn-outline-secondary btn-sm" onclick="clearFilters()">Clear</button>
            </div>
            <div class="d-flex gap-2 align-items-center">
                <span class="text-light" style="opacity: 0.5;">
                    <span id="totalCount">0</span> photos
                </span>
                <button class="btn btn-outline-success btn-sm" onclick="refreshPhotos()">
                    <i class="bi bi-arrow-repeat"></i> Fetch New
                </button>
            </div>
        </div>
    </div>
</div>

<!-- WildLogic HQ Gate -->
<div id="hqGate">
    <div class="card login-card">
        <div class="card-body p-4">
            <div class="text-center mb-4">
                <i class="bi bi-shield-lock-fill text-warning" style="font-size: 3rem;"></i>
                <h4 class="mt-2" style="color: var(--accent-gold);">WildLogic HQ</h4>
                <p class="text-muted">Enter access code to continue</p>
            </div>
            <div class="mb-4">
                <input type="password" class="form-control text-center" id="hqPassword" placeholder="Access Code" onkeypress="if(event.key === 'Enter') checkHqAccess()">
            </div>
            <div class="d-grid gap-2">
                <button class="btn btn-warning" onclick="checkHqAccess()">
                    <i class="bi bi-unlock-fill me-2"></i>Enter
                </button>
            </div>
            <div id="hqError" class="alert alert-danger mt-3" style="display: none;">Invalid access code</div>
            <hr class="my-4">
            <div class="d-grid gap-2">
                <button class="btn btn-outline-secondary" onclick="viewOnlyLogin()">
                    <i class="bi bi-eye-fill me-2"></i>View Only
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Main Content -->
<div id="mainContent" style="display: none;">
    <div class="tab-content">
        
        <!-- Photos Tab -->
        <div class="tab-pane fade" id="photosContent" role="tabpanel">
            <div class="container-fluid py-3">
                
                <!-- Grid View -->
                <div id="gridContainer">
                    <div class="row">
                        <div class="col-lg-10">
                            <div class="photo-grid" id="photoGrid"></div>
                            <div class="text-center mt-3" id="gridLoadMore" style="display: none;">
                                <button class="btn btn-outline-secondary" onclick="loadMoreGridItems()">Load More</button>
                            </div>
                        </div>
                        <div class="col-lg-2 admin-only">
                            <div class="card">
                                <div class="card-body grid-sidebar">
                                    <div class="grid-selected-count" id="gridSelectedCount">None selected</div>
                                    <button class="btn btn-primary btn-sm" id="selectToggleBtn" onclick="toggleSelectAll()">Select All</button>
                                    <button class="btn btn-warning btn-sm" id="selectUntaggedBtn" onclick="selectUntagged()">Select Untagged</button>
                                    <hr class="my-2 admin-only">
                                    <select id="bulkTagDropdown" class="form-select form-select-sm admin-only" onchange="bulkTagFromDropdown()" disabled>
                                        <option value=""> Tag...</option>
                                        <option value="__none__"> Clear</option>
                                        <option value="Buck"> Buck</option>
                                        <option value="Doe"> Doe</option>
                                        <option value="Turkey"> Turkey</option>
                                        <option value="Bear"> Bear</option>
                                        <option value="Predator"> Predator</option>
                                        <option value="Bird"> Bird</option>
                                        <option value="Human"> Human</option>
                                        <option value="Vehicle/ATV"> Vehicle</option>
                                        <option value="Other"> Other</option>
                                        <option value="No Animals"> No Animals</option>
                                    </select>
                                    <hr class="my-2 admin-only">
                                    <button class="btn btn-success btn-sm admin-only" id="bulkGalleryBtn" onclick="openBulkGalleryModal()" disabled>
                                        <i class="bi bi-folder-plus me-1"></i>Gallery
                                    </button>
                                    <button class="btn btn-info btn-sm" id="bulkDownloadBtn" onclick="bulkDownload()" disabled>
                                        <i class="bi bi-download me-1"></i>Download
                                    </button>
                                    <button class="btn btn-danger btn-sm admin-only" id="bulkDeleteBtn" onclick="openBulkDeleteModal()" disabled>
                                        <i class="bi bi-trash me-1"></i>Delete
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- No Photos Message -->
                <div id="completeMessage" class="text-center py-5" style="display: none;">
                    <i class="bi bi-camera text-muted" style="font-size: 4rem;"></i>
                    <h4 class="mt-3">No Photos Found</h4>
                    <p class="text-muted" id="completeSummary">No photos match the current filter.</p>
                </div>
                
            </div>
        </div>
        
        <!-- Dashboard Tab -->
        <div class="tab-pane fade show active" id="dashboardContent" role="tabpanel">
            <div class="container-fluid">
                
                <!-- Conditions Overview -->
                <div class="card mb-2 mt-2">
                    <div class="card-body py-2">
                        <div class="row align-items-center">
                            <!-- Optimal Hunt (Left) -->
                            <div class="col-md-6">
                                <div class="d-flex align-items-center gap-3 flex-wrap">
                                    <span class="text-success fw-bold"><i class="bi bi-bullseye me-1"></i>Optimal Hunt:</span>
                                    <div id="optimalConditions" class="d-flex gap-3 flex-wrap" style="font-size: 13px; color: #E0E0E3;">
                                        <span class="text-muted">Loading...</span>
                                    </div>
                                </div>
                            </div>
                            <!-- Current Conditions (Right) -->
                            <div class="col-md-6">
                                <div class="d-flex align-items-center gap-3 flex-wrap justify-content-end">
                                    <span class="text-info fw-bold"><i class="bi bi-cloud-sun me-1"></i>Current:</span>
                                    <div id="currentConditions" class="d-flex gap-3 flex-wrap" style="font-size: 13px; color: #E0E0E3;">
                                        <span class="text-muted">Loading...</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Activity Prediction & Forecast Charts -->
                <div class="card mb-2">
                    <div class="card-body">
                        <div class="row">
                            <!-- Activity Prediction -->
                            <div class="col-md-6">
                                <div id="chart_prediction"></div>
                            </div>
                            <!-- Forecast -->
                            <div class="col-md-6">
                                <div id="chart_forecast"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Main Chart -->
                <div class="card mb-2" style="overflow: visible;">
                    <div class="card-body" style="overflow: visible;">
                        <div class="row">
                            <div class="col-8" style="overflow: visible;">
                                <div id="chart_main"></div>
                            </div>
                            <div class="col-4">
                                <div id="tooltipPanel" class="tooltip-panel">
                                    <div class="text-muted text-center py-5">
                                        <i class="bi bi-cursor" style="font-size: 2rem;"></i>
                                        <p class="mt-2 mb-0">Hover over a point to see details</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Polar Chart -->
                <div class="card mb-2">
                    <div class="card-body">
                        <div class="row">
                            <div class="col-md-6 d-flex flex-column align-items-center">
                                <div class="d-flex align-items-center gap-2 mb-2">
                                    <span class="fw-bold" style="color: #E0E0E3; font-size: 18px;">Photos by:</span>
                                    <button type="button" class="weather-field-btn active" id="btnWindDirection" onclick="selectWeatherField('windDirection')">Wind Dir</button>
                                    <button type="button" class="weather-field-btn" id="btnWindSpeed" onclick="selectWeatherField('windSpeed')">Wind Spd</button>
                                    <button type="button" class="weather-field-btn" id="btnTemperature" onclick="selectWeatherField('temperature')">Temp</button>
                                    <button type="button" class="weather-field-btn" id="btnPressure" onclick="selectWeatherField('pressure')">Press</button>
                                    <button type="button" class="weather-field-btn" id="btnMoonPhase" onclick="selectWeatherField('moonPhase')">Moon</button>
                                </div>
                                <div id="chart_weather"></div>
                            </div>
                            <div class="col-md-6 d-flex justify-content-center">
                                <div id="chart_polar"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
            </div>
        </div>
        
        <!-- Settings Tab -->
        <div class="tab-pane fade" id="accountContent" role="tabpanel">
            <div class="container-fluid py-3">
                <div class="row justify-content-center">
                    <div class="col-lg-8">
                        <h4 class="mb-4"><i class="bi bi-gear me-2"></i>Settings</h4>
                        
                        <!-- Camera Services Section -->
                        <div class="card mb-4 admin-only">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <span><i class="bi bi-camera-video me-2"></i>Camera Services</span>
                            </div>
                            <div class="card-body">
                                
                                <!-- Reveal/Tactacam -->
                                <div class="border rounded p-3 mb-3" style="background: var(--bg-dark);">
                                    <div class="d-flex justify-content-between align-items-center mb-3">
                                        <h6 class="mb-0"><i class="bi bi-broadcast-pin text-warning me-2"></i>Reveal by Tactacam</h6>
                                        <span class="badge bg-success" id="revealStatus">Connected</span>
                                    </div>
                                    <div class="row g-3">
                                        <div class="col-md-6">
                                            <label class="form-label small text-muted">Email</label>
                                            <input type="email" class="form-control form-control-sm" id="revealEmail" placeholder="your@email.com">
                                        </div>
                                        <div class="col-md-6">
                                            <label class="form-label small text-muted">Password</label>
                                            <div class="input-group input-group-sm">
                                                <input type="password" class="form-control" id="revealPassword" placeholder="">
                                                <button class="btn btn-outline-secondary" type="button" onclick="togglePasswordVisibility('revealPassword', this)">
                                                    <i class="bi bi-eye"></i>
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="mt-3 d-flex gap-2">
                                        <button class="btn btn-outline-success btn-sm" onclick="testRevealConnection()">
                                            <i class="bi bi-plug me-1"></i>Test Connection
                                        </button>
                                        <button class="btn btn-success btn-sm" onclick="saveRevealCredentials()">
                                            <i class="bi bi-check-lg me-1"></i>Save
                                        </button>
                                    </div>
                                </div>
                                
                                <!-- Placeholder for future services -->
                                <div class="border rounded p-3 text-center" style="background: var(--bg-dark); border-style: dashed !important;">
                                    <i class="bi bi-plus-circle text-muted" style="font-size: 2rem;"></i>
                                    <p class="text-muted small mt-2 mb-0">Additional camera services coming soon</p>
                                </div>
                                
                            </div>
                        </div>
                        
                        <!-- Prediction Weights Section -->
                        <div class="card mb-4">
                            <div class="card-header">
                                <i class="bi bi-sliders me-2"></i>Prediction Weights
                            </div>
                            <div class="card-body">
                                <p class="text-muted small mb-3">Adjust how much each weather factor influences the Activity Prediction score (must total 100%).</p>
                                <div class="row g-3">
                                    <div class="col-12 col-md-6">
                                        <div class="d-flex justify-content-between">
                                            <label class="form-label small mb-1" style="color: #AF7AC5;">Pressure</label>
                                            <span class="small" id="weightPressureValue" style="color: #AF7AC5;">30%</span>
                                        </div>
                                        <input type="range" id="weightPressure" value="30" min="0" max="100" step="5" class="form-range" oninput="updateWeightSlider(this)">
                                    </div>
                                    <div class="col-12 col-md-6">
                                        <div class="d-flex justify-content-between">
                                            <label class="form-label small mb-1" style="color: #7FB3D5;">Wind Direction</label>
                                            <span class="small" id="weightWindDirValue" style="color: #7FB3D5;">20%</span>
                                        </div>
                                        <input type="range" id="weightWindDir" value="20" min="0" max="100" step="5" class="form-range" oninput="updateWeightSlider(this)">
                                    </div>
                                    <div class="col-12 col-md-6">
                                        <div class="d-flex justify-content-between">
                                            <label class="form-label small mb-1" style="color: #7FB3D5;">Wind Speed</label>
                                            <span class="small" id="weightWindSpeedValue" style="color: #7FB3D5;">20%</span>
                                        </div>
                                        <input type="range" id="weightWindSpeed" value="20" min="0" max="100" step="5" class="form-range" oninput="updateWeightSlider(this)">
                                    </div>
                                    <div class="col-12 col-md-6">
                                        <div class="d-flex justify-content-between">
                                            <label class="form-label small mb-1" style="color: #D4AC0D;">Moon Phase</label>
                                            <span class="small" id="weightMoonValue" style="color: #D4AC0D;">20%</span>
                                        </div>
                                        <input type="range" id="weightMoon" value="20" min="0" max="100" step="5" class="form-range" oninput="updateWeightSlider(this)">
                                    </div>
                                    <div class="col-12 col-md-6">
                                        <div class="d-flex justify-content-between">
                                            <label class="form-label small mb-1" style="color: #F4D03F;">Temperature</label>
                                            <span class="small" id="weightTempValue" style="color: #F4D03F;">10%</span>
                                        </div>
                                        <input type="range" id="weightTemp" value="10" min="0" max="100" step="5" class="form-range" oninput="updateWeightSlider(this)">
                                    </div>
                                    <div class="col-12 col-md-6 d-flex align-items-center justify-content-center">
                                        <span class="fw-bold" id="totalWeightDisplay" style="color: #4CAF50;">Total: 100%</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Cache Settings -->
                        <div class="card mb-4 admin-only">
                            <div class="card-header">
                                <i class="bi bi-hdd me-2"></i>Cache Settings
                            </div>
                            <div class="card-body">
                                <div class="d-flex justify-content-between align-items-center">
                                    <div>
                                        <p class="mb-1">Local photo cache</p>
                                        <small class="text-muted" id="cacheInfo">Loading cache info...</small>
                                    </div>
                                    <button class="btn btn-outline-danger btn-sm" onclick="clearLocalCache()">
                                        <i class="bi bi-trash me-1"></i>Clear Cache
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Data Management -->
                        <div class="card mb-4 admin-only">
                            <div class="card-header">
                                <i class="bi bi-arrow-repeat me-2"></i>Data Management
                            </div>
                            <div class="card-body">
                                <div class="d-flex flex-wrap gap-3">
                                    <div>
                                        <button class="btn btn-outline-info btn-sm" id="cloudSyncBtn" onclick="syncToCloudBackup()" style="display: none;" title="Sync to Cloud Backup">
                                            <i class="bi bi-cloud-upload me-1"></i>Sync to Cloud
                                        </button>
                                        <small class="d-block text-muted mt-1">Upload local data to cloud backup</small>
                                    </div>
                                    <div>
                                        <button class="btn btn-outline-danger btn-sm" id="fullRefreshBtn" onclick="fullRefresh()" style="display: none;" title="Full Refresh - Clear ALL Cache & Reload from Reveal">
                                            <i class="bi bi-arrow-clockwise me-1"></i>Full Refresh
                                        </button>
                                        <small class="d-block text-muted mt-1">Clear cache & reload from Reveal</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                    </div>
                </div>
            </div>
        </div>
        
    </div>
</div>
<div class="modal fade" id="galleryModal" tabindex="-1">
    <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content bg-dark">
            <div class="modal-header border-secondary">
                <h5 class="modal-title"><i class="bi bi-folder-plus me-2"></i>Gallery</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="row g-3" id="galleryGrid"></div>
            </div>
        </div>
    </div>
</div>

<!-- Bulk Gallery Modal -->
<div class="modal fade" id="bulkGalleryModal" tabindex="-1">
    <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content bg-dark">
            <div class="modal-header border-secondary">
                <h5 class="modal-title"><i class="bi bi-folder-plus me-2"></i>Gallery</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="row g-3" id="bulkGalleryGrid"></div>
            </div>
        </div>
    </div>
</div>

<!-- Bulk Delete Modal -->
<div class="modal fade" id="bulkDeleteModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content bg-dark">
            <div class="modal-header border-secondary">
                <h5 class="modal-title"><i class="bi bi-trash me-2"></i>Delete Selected Photos</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body text-center">
                <p>Are you sure you want to delete <strong id="bulkDeleteCount">0</strong> photos?</p>
                <p class="text-muted small">This action cannot be undone.</p>
            </div>
            <div class="modal-footer border-secondary">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-danger" onclick="confirmBulkDelete()">Delete All</button>
            </div>
        </div>
    </div>
</div>

<!-- Rapid Fire Confirmation Modal -->
<div class="modal fade" id="rapidFireModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content bg-dark">
            <div class="modal-header border-secondary">
                <h5 class="modal-title"><i class="bi bi-lightning-fill me-2" style="color: var(--accent-gold);"></i>Rapid Fire Mode</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <p>Rapid Fire mode enables quick photo processing:</p>
                <ul>
                    <li>Auto-advance to next photo after tagging</li>
                    <li><strong style="color: var(--accent-red);">Immediate delete</strong> without confirmation</li>
                </ul>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" onclick="cancelRapidFire()">Cancel</button>
                <button type="button" class="btn btn-warning" onclick="confirmRapidFire()">OK</button>
            </div>
        </div>
    </div>
</div>

<!-- Quick Tag Zoom Modal -->
<div id="zoomModal" class="zoom-modal-overlay" style="display: none;" onclick="closeZoomModal()">
    <div class="zoom-modal-container" onclick="event.stopPropagation()">
        <div class="zoom-image-wrapper">
            <div class="zoom-nav-zone left" id="zoomNavLeft" onclick="zoomPrev()">
                <span class="zoom-nav-arrow"></span>
            </div>
            <img id="zoomImage" class="zoom-modal-img" src="" alt="Photo" />
            <div class="zoom-nav-zone right" id="zoomNavRight" onclick="zoomNext()">
                <span class="zoom-nav-arrow"></span>
            </div>
        </div>
        <div class="zoom-progress-wrapper">
            <div class="progress">
                <div class="progress-bar" id="zoomProgress" role="progressbar" style="width: 0%"></div>
            </div>
        </div>
        <div class="zoom-info" id="zoomInfo"></div>
        <div class="zoom-actions-wrapper">
            <div class="zoom-left-section">
                <span class="zoom-rapid-label" id="rapidFireLabel" onclick="handleRapidFireClick()">Rapid Fire</span>
            </div>
            <div class="zoom-actions" id="zoomActions"></div>
            <div class="zoom-right-section">
                <button class="zoom-gallery-btn admin-only" id="zoomGalleryBtn" onclick="openGalleryModal()"><i class="bi bi-folder-plus"></i> Gallery</button>
                <button class="zoom-download-btn" onclick="zoomDownloadPhoto()"><i class="bi bi-download"></i> Download</button>
            </div>
        </div>
    </div>
</div>

<!-- Bootstrap JS -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

<script>
// ============== CONFIG ==============
const CONFIG = {
    cognitoUrl: 'https://cognito-idp.us-east-1.amazonaws.com/',
    cognitoClientId: '6r9tpojvgvkci5trla0ip14mon',
    apiBaseUrl: 'https://api.reveal.ishareit.net/v1',
    visualCrossingApiKey: '3PHP49SVRX5U75Q4CSD5R995P',
    fixedLat: 35.28705,
    fixedLng: -82.48265,
    fixedLocationName: 'Hendersonville, NC',
    timezoneOffset: -5,
    // Google Drive JSON Cache
    googleSheetsUrl: 'https://script.google.com/macros/s/AKfycbz11U24W_KnkhgpONyk5hESy_d40uTYkTT1BsTzYdEQvnvPYF-N7PMHdtEJdvLpM3o3/exec'
};

// Access level: 'admin', 'viewer', or null
let accessLevel = null;

// ============== TRAIL CAM HQ ACCESS ==============
async function checkHqAccess() {
    const code = document.getElementById('hqPassword').value;
    if (!code) {
        document.getElementById('hqError').style.display = 'block';
        return;
    }
    
    document.getElementById('hqError').style.display = 'none';
    showLoading('Verifying access...');
    
    try {
        const response = await fetch(`${CONFIG.googleSheetsUrl}?action=verifyAccess&code=${encodeURIComponent(code)}`);
        const result = await response.json();
        
        hideLoading();
        
        if (result.access === 'admin' || result.access === 'viewer') {
            accessLevel = result.access;
            sessionStorage.setItem('hqAccess', accessLevel);
            document.getElementById('hqGate').style.display = 'none';
            // Go directly to login
            adminQuickLogin();
        } else {
            document.getElementById('hqError').style.display = 'block';
            document.getElementById('hqPassword').value = '';
        }
    } catch (error) {
        hideLoading();
        console.error('Access check error:', error);
        document.getElementById('hqError').textContent = 'Connection error. Try again.';
        document.getElementById('hqError').style.display = 'block';
    }
}

async function adminQuickLogin() {
    showLoading('Connecting...');
    
    try {
        // Get stored credentials from Apps Script
        const response = await fetch(`${CONFIG.googleSheetsUrl}?action=getViewerCredentials&session=viewer`);
        const creds = await response.json();
        
        if (creds.error || !creds.email || !creds.password) {
            throw new Error('Could not retrieve credentials');
        }
        
        // Login to Tactacam
        showLoading('Signing in...');
        const authResponse = await fetch(CONFIG.cognitoUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-amz-json-1.1', 'X-Amz-Target': 'AWSCognitoIdentityProviderService.InitiateAuth' },
            body: JSON.stringify({
                AuthFlow: 'USER_PASSWORD_AUTH',
                ClientId: CONFIG.cognitoClientId,
                AuthParameters: { USERNAME: creds.email, PASSWORD: creds.password }
            })
        });
        
        const authData = await authResponse.json();
        
        if (!authData.AuthenticationResult) {
            throw new Error(authData.message || 'Login failed');
        }
        
        accessToken = authData.AuthenticationResult.AccessToken;
        localStorage.setItem('trailcam_token', accessToken);
        localStorage.setItem('trailcam_email', creds.email);
        
        // Defer local cache saves during login - we'll do one save at the end
        deferLocalCacheSave = true;
        
        // Initialize app (loads from cache)
        await initializeApp();
        
        // Check for new photos and sync to cache
        showSyncStatus('Checking for new photos...', 'syncing');
        
        try {
            const existingIds = new Set(allPhotos.map(p => p.photoId));
            let newPhotos = [];
            let page = 0;
            
            while (page < 10) {
                const resp = await fetch(
                    `${CONFIG.apiBaseUrl}/photos?size=100&page=${page}&includeWeatherData=true`,
                    { headers: { 'Authorization': `Bearer ${accessToken}` } }
                );
                
                if (!resp.ok) break;
                const photoData = await resp.json();
                if (!photoData.response?.photos?.length) break;
                
                let foundExisting = false;
                for (const photo of photoData.response.photos) {
                    if (existingIds.has(photo.photoId)) { foundExisting = true; continue; }
                    if (!photo.photoDateUtc && !photo.photoDate) continue;
                    if (photo.cameraName) cameras.add(photo.cameraName);
                    if (photo.cameraLocation) locations.add(photo.cameraLocation);
                    allPhotos.unshift(photo);
                    newPhotos.push(photo);
                }
                if (foundExisting) break;
                page++;
            }
            
            if (newPhotos.length > 0) {
                applyFilters();
                showSyncStatus(`Syncing ${newPhotos.length} new photos...`, 'syncing');
                await syncPhotosToCache(newPhotos);
                showSyncStatus(`${newPhotos.length} new photos synced!`, 'complete');
                setTimeout(() => hideSyncStatus(), 3000);
            } else {
                showSyncStatus('All photos up to date', 'complete');
                setTimeout(() => hideSyncStatus(), 2000);
            }
        } catch (refreshError) {
            console.error('Refresh error:', refreshError);
            showSyncStatus('Using cached photos', 'complete');
            setTimeout(() => hideSyncStatus(), 2000);
        }
        
        // Now do one final save to local cache
        deferLocalCacheSave = false;
        await saveCurrentStateToLocalCache();
        console.log('Final local cache save complete');
        
    } catch (error) {
        deferLocalCacheSave = false;
        hideLoading();
        console.error('Admin login error:', error);
        alert('Connection failed. Please try again.');
    }
}

async function checkHqSession() {
    const savedAccess = sessionStorage.getItem('hqAccess');
    const savedToken = localStorage.getItem('trailcam_token');
    const savedEmail = localStorage.getItem('trailcam_email');
    
    // If we have a saved token, try to restore the session
    if (savedAccess && savedToken && savedEmail) {
        accessLevel = savedAccess;
        accessToken = savedToken;
        
        // Validate token by making a quick API call
        try {
            showLoading('Restoring session...');
            const response = await fetch(`${CONFIG.apiBaseUrl}/photo-tags`, {
                headers: { 'Authorization': `Bearer ${accessToken}` }
            });
            
            if (response.ok) {
                // Token is valid - go straight to app
                console.log('Session restored from saved token');
                document.getElementById('hqGate').style.display = 'none';
                applyAccessLevel();
                await initializeApp();
                return true;
            } else {
                // Token expired - clear and show login
                console.log('Saved token expired');
                localStorage.removeItem('trailcam_token');
                localStorage.removeItem('trailcam_email');
                hideLoading();
            }
        } catch (e) {
            console.log('Token validation failed:', e);
            localStorage.removeItem('trailcam_token');
            localStorage.removeItem('trailcam_email');
            hideLoading();
        }
    }
    
    // Fall back to showing HQ Gate
    if (savedAccess === 'admin' || savedAccess === 'viewer') {
        accessLevel = savedAccess;
        document.getElementById('hqGate').style.display = 'none';
        // Go directly to login
        adminQuickLogin();
        return true;
    }
    return false;
}

function applyAccessLevel() {
    // Hide admin-only elements for viewers
    const adminElements = document.querySelectorAll('.admin-only');
    adminElements.forEach(el => {
        el.style.display = accessLevel === 'admin' ? '' : 'none';
    });
    
    console.log('Access level:', accessLevel);
}

async function viewOnlyLogin() {
    showLoading('Connecting...');
    
    try {
        // Step 1: Get stored credentials from Apps Script
        const response = await fetch(`${CONFIG.googleSheetsUrl}?action=getViewerCredentials&session=viewer`);
        const creds = await response.json();
        
        if (creds.error || !creds.email || !creds.password) {
            throw new Error('Could not retrieve credentials');
        }
        
        // Step 2: Login to Tactacam
        showLoading('Signing in...');
        const authResponse = await fetch(CONFIG.cognitoUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-amz-json-1.1', 'X-Amz-Target': 'AWSCognitoIdentityProviderService.InitiateAuth' },
            body: JSON.stringify({
                AuthFlow: 'USER_PASSWORD_AUTH',
                ClientId: CONFIG.cognitoClientId,
                AuthParameters: { USERNAME: creds.email, PASSWORD: creds.password }
            })
        });
        
        const authData = await authResponse.json();
        
        if (!authData.AuthenticationResult) {
            throw new Error(authData.message || 'Login failed');
        }
        
        accessToken = authData.AuthenticationResult.AccessToken;
        accessLevel = 'viewer';
        sessionStorage.setItem('hqAccess', accessLevel);
        localStorage.setItem('trailcam_token', accessToken);
        localStorage.setItem('trailcam_email', 'QuickView');
        
        // Hide HQ Gate
        document.getElementById('hqGate').style.display = 'none';
        applyAccessLevel();
        
        // Step 3: Initialize app (loads from cache)
        await initializeApp();
        
        // Step 4: Refresh for new photos in background
        // Admin: sync new photos to cache
        // Viewer: just display new photos, don't sync
        showSyncStatus('Checking for new photos...', 'syncing');
        
        try {
            const existingIds = new Set(allPhotos.map(p => p.photoId));
            let newPhotos = [];
            let page = 0;
            
            while (page < 10) { // Check first 10 pages for new photos
                const resp = await fetch(
                    `${CONFIG.apiBaseUrl}/photos?size=100&page=${page}&includeWeatherData=true`,
                    { headers: { 'Authorization': `Bearer ${accessToken}` } }
                );
                
                if (!resp.ok) break;
                const data = await resp.json();
                if (!data.response?.photos?.length) break;
                
                let foundExisting = false;
                for (const photo of data.response.photos) {
                    if (existingIds.has(photo.photoId)) { foundExisting = true; continue; }
                    if (!photo.photoDateUtc && !photo.photoDate) continue;
                    if (photo.cameraName) cameras.add(photo.cameraName);
                    if (photo.cameraLocation) locations.add(photo.cameraLocation);
                    allPhotos.unshift(photo);
                    newPhotos.push(photo);
                }
                if (foundExisting) break;
                page++;
            }
            
            if (newPhotos.length > 0) {
                applyFilters();
                
                // Admin syncs to cache, viewer does not
                if (accessLevel === 'admin') {
                    showSyncStatus(`Syncing ${newPhotos.length} new photos...`, 'syncing');
                    await syncPhotosToCache(newPhotos);
                    showSyncStatus(`${newPhotos.length} new photos synced!`, 'complete');
                } else {
                    showSyncStatus(`${newPhotos.length} new photos loaded`, 'complete');
                }
                setTimeout(() => hideSyncStatus(), 3000);
            } else {
                showSyncStatus('All photos up to date', 'complete');
                setTimeout(() => hideSyncStatus(), 2000);
            }
        } catch (refreshError) {
            console.error('Refresh error:', refreshError);
            showSyncStatus('Using cached photos', 'complete');
            setTimeout(() => hideSyncStatus(), 2000);
        }
        
    } catch (error) {
        hideLoading();
        console.error('View only login error:', error);
        alert('Connection failed. Please try again.');
    }
}

// Check on page load
document.addEventListener('DOMContentLoaded', function() {
    // Clean up logout URL parameter
    if (window.location.search.includes('logout=')) {
        window.history.replaceState({}, document.title, window.location.pathname);
    }
    checkHqSession();
});

// ============== STATE ==============
let accessToken = null;
let allPhotos = [];
let filteredPhotos = [];
let currentIndex = 0;
let tagsLookup = {};
let tagIdToName = {};
let groupsLookup = {};
let galleries = [];
let cameras = new Set();
let locations = new Set();
let gridDisplayCount = 100;
let selectedPhotos = new Set();
let cacheEnabled = false; // Set to true once Google Sheets URL is configured

// Dashboard state
let sunData = {};
let moonData = {};
let cachedForecastData = null;
let forecastDays = [];
let sunriseArray = [];
let sunsetArray = [];
let moonArray = [];
let dashboardInitialized = false;

// Dynamic tag arrays - keyed by tag type
let tagArrays = {};
const tagConfig = {
    'buck': { color: '#FF4444', symbol: 'triangle', radius: 5, name: 'Buck' },
    'doe': { color: '#1C86EE', symbol: 'circle', radius: 4, name: 'Doe' },
    'turkey': { color: '#FF8C00', symbol: 'square', radius: 4, name: 'Turkey' },
    'bear': { color: '#8B4513', symbol: 'diamond', radius: 5, name: 'Bear' },
    'predator': { color: '#9932CC', symbol: 'triangle-down', radius: 5, name: 'Predator' },
    'bird': { color: '#00CED1', symbol: 'circle', radius: 3, name: 'Bird' },
    'human': { color: '#FFD700', symbol: 'square', radius: 4, name: 'Human' },
    'vehicle': { color: '#A9A9A9', symbol: 'diamond', radius: 4, name: 'Vehicle/ATV' },
    'other_tagged': { color: '#90EE90', symbol: 'circle', radius: 3, name: 'Other' },
    'no_animals': { color: '#696969', symbol: 'circle', radius: 3, name: 'No Animals' },
    'untagged': { color: '#FFFFFF', symbol: 'circle', radius: 3, name: 'Untagged' }
};

// Bootstrap modals
let galleryModalInstance, bulkGalleryModalInstance, bulkDeleteModalInstance, rapidFireModalInstance;

// ============== LOADING ==============
function showLoading(msg = 'Loading...') {
    document.getElementById('loadingText').textContent = msg;
    document.getElementById('loadingOverlay').style.display = 'flex';
}

function hideLoading() {
    document.getElementById('loadingOverlay').style.display = 'none';
}

function showSyncStatus(msg, status = 'syncing') {
    const el = document.getElementById('syncStatus');
    const textEl = document.getElementById('syncStatusText');
    const icons = {
        syncing: 'bi-cloud-upload',
        complete: 'bi-check-circle-fill',
        error: 'bi-exclamation-triangle-fill'
    };
    el.className = status;
    el.querySelector('i').className = 'bi ' + (icons[status] || icons.syncing);
    textEl.textContent = msg;
    el.style.display = 'block';
}

function hideSyncStatus() {
    document.getElementById('syncStatus').style.display = 'none';
}

async function loadFromAPI() {
    await loadTags();
    await loadPhotoGroups();
    await loadGalleries();
    await loadPhotos();
}

function updatePhotoCount() {
    document.getElementById('totalCount').textContent = filteredPhotos.length.toLocaleString();
}

// ============== AUTH ==============
function logout() {
    // Clear all stored data
    accessToken = null;
    accessLevel = null;
    localStorage.removeItem('trailcam_token');
    localStorage.removeItem('trailcam_email');
    sessionStorage.removeItem('hqAccess');
    
    // Hard refresh with cache bust
    window.location.href = window.location.pathname + '?logout=' + Date.now();
}

async function checkSession() {
    // Skip session restore - require fresh login
    // This avoids CORS issues on initial page load
    hideLoading();
}

// ============== GOOGLE DRIVE JSON CACHE ==============
function isCacheEnabled() {
    return CONFIG.googleSheetsUrl && CONFIG.googleSheetsUrl !== 'YOUR_GOOGLE_APPS_SCRIPT_URL_HERE';
}

// ============== LOCAL STORAGE CACHE (PRIMARY - INSTANT) ==============
// Using IndexedDB for larger storage capacity (localStorage is limited to ~5MB)
const LOCAL_CACHE_KEY = 'trailcam_cache_v2';
const LOCAL_CACHE_VERSION = 2;
const DB_NAME = 'TrailCamDB';
const DB_VERSION = 1;
const STORE_NAME = 'cache';

let dbInstance = null;
let deferLocalCacheSave = false; // Flag to batch saves during login

// Initialize IndexedDB
function initDB() {
    return new Promise((resolve, reject) => {
        if (dbInstance) {
            resolve(dbInstance);
            return;
        }
        
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        
        request.onerror = () => {
            console.error('IndexedDB error:', request.error);
            reject(request.error);
        };
        
        request.onsuccess = () => {
            dbInstance = request.result;
            console.log('IndexedDB initialized');
            resolve(dbInstance);
        };
        
        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
                db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                console.log('IndexedDB store created');
            }
        };
    });
}

async function saveToLocalCache(data) {
    try {
        const db = await initDB();
        const cacheData = {
            id: LOCAL_CACHE_KEY,
            version: LOCAL_CACHE_VERSION,
            timestamp: Date.now(),
            ...data
        };
        
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.put(cacheData);
            
            request.onsuccess = () => {
                console.log(' Local cache saved successfully (IndexedDB):', {
                    photos: data.photos?.length || 0,
                    tags: data.tags?.length || 0,
                    galleries: data.galleries?.length || 0,
                    sunDataDates: Object.keys(data.sunData || {}).length
                });
                resolve(true);
            };
            
            request.onerror = () => {
                console.error('IndexedDB save error:', request.error);
                reject(request.error);
            };
        });
    } catch (e) {
        console.error('Local cache save error:', e);
        return false;
    }
}

async function loadFromLocalCache() {
    console.log('Attempting to load from local cache (IndexedDB)');
    try {
        const db = await initDB();
        
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([STORE_NAME], 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.get(LOCAL_CACHE_KEY);
            
            request.onsuccess = () => {
                const data = request.result;
                
                if (!data) {
                    console.log(' No local cache found in IndexedDB');
                    resolve(null);
                    return;
                }
                
                // Check version compatibility
                if (data.version !== LOCAL_CACHE_VERSION) {
                    console.log(' Local cache version mismatch:', data.version, 'vs expected', LOCAL_CACHE_VERSION);
                    resolve(null);
                    return;
                }
                
                // Check if cache is stale (older than 7 days)
                const cacheAge = Date.now() - (data.timestamp || 0);
                const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days
                if (cacheAge > maxAge) {
                    console.log('Local cache is stale, will refresh from cloud');
                    data._stale = true;
                }
                
                console.log(' Loaded from local cache (IndexedDB):', {
                    photos: data.photos?.length || 0,
                    tags: data.tags?.length || 0,
                    galleries: data.galleries?.length || 0,
                    sunDataDates: Object.keys(data.sunData || {}).length,
                    ageHours: Math.round(cacheAge / (60 * 60 * 1000))
                });
                
                resolve(data);
            };
            
            request.onerror = () => {
                console.error('IndexedDB load error:', request.error);
                resolve(null);
            };
        });
    } catch (e) {
        console.error('Local cache load error:', e);
        return null;
    }
}

async function updateLocalCacheSunData(newSunData) {
    try {
        const existing = await loadFromLocalCache();
        if (!existing) return false;
        
        existing.sunData = { ...existing.sunData, ...newSunData };
        existing.timestamp = Date.now();
        await saveToLocalCache(existing);
        return true;
    } catch (e) {
        console.error('Local cache update error:', e);
        return false;
    }
}

async function clearLocalCache() {
    try {
        const db = await initDB();
        return new Promise((resolve) => {
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.delete(LOCAL_CACHE_KEY);
            
            request.onsuccess = () => {
                console.log('Local cache cleared (IndexedDB)');
                resolve(true);
            };
            
            request.onerror = () => {
                console.error('IndexedDB clear error:', request.error);
                resolve(false);
            };
        });
    } catch (e) {
        console.error('Clear cache error:', e);
        // Also try clearing old localStorage just in case
        localStorage.removeItem('trailcam_cache_v2');
        return false;
    }
}

// ============== GOOGLE SHEETS CACHE (BACKUP - CLOUD) ==============
async function loadFromCloudCache() {
    if (!isCacheEnabled()) return null;
    
    try {
        showLoading('Loading from cloud backup...');
        const response = await fetch(`${CONFIG.googleSheetsUrl}?action=getAll`);
        if (!response.ok) throw new Error('Cloud cache fetch failed: ' + response.status);
        const data = await response.json();
        if (data.error) throw new Error(data.error);
        console.log('Loaded from cloud cache:', {
            photos: data.photos?.length || 0,
            tags: data.tags?.length || 0,
            galleries: data.galleries?.length || 0,
            sunDataDates: Object.keys(data.sunData || {}).length,
            moonDataEntries: Object.keys(data.moonData || {}).length
        });
        return data;
    } catch (error) {
        console.error('Cloud cache load error:', error);
        return null;
    }
}

// ============== HYBRID CACHE LOADER ==============
async function loadFromCache() {
    console.log('=== loadFromCache starting ===');
    
    // Try local cache first (instant)
    const localData = await loadFromLocalCache();
    
    if (localData && localData.photos && localData.photos.length > 0) {
        // Local cache hit!
        console.log(' Using local cache with', localData.photos.length, 'photos');
        if (localData._stale) {
            console.log('Using stale local cache, will sync from cloud in background');
            // Schedule background cloud sync
            setTimeout(async () => {
                const cloudData = await loadFromCloudCache();
                if (cloudData && cloudData.photos) {
                    await saveToLocalCache(cloudData);
                    console.log('Background cloud sync complete');
                }
            }, 5000);
        }
        return localData;
    }
    
    // No local cache - try cloud
    console.log(' Local cache empty or invalid, falling back to cloud');
    if (!isCacheEnabled()) {
        console.log('Cloud cache not enabled');
        return null;
    }
    
    console.log('Loading from cloud...');
    const cloudData = await loadFromCloudCache();
    
    if (cloudData && cloudData.photos && cloudData.photos.length > 0) {
        // Save to local cache for next time
        console.log('Saving cloud data to local cache for next time');
        await saveToLocalCache(cloudData);
    }
    
    return cloudData;
}

async function postToCache(data) {
    if (!isCacheEnabled()) return null;
    
    try {
        const response = await fetch(CONFIG.googleSheetsUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify(data)
        });
        return await response.json();
    } catch (error) {
        console.error('Cache POST error:', error);
        return null;
    }
}

// Save current state to local cache
async function saveCurrentStateToLocalCache() {
    // Skip if saves are being deferred (during bulk operations like login)
    if (deferLocalCacheSave) {
        console.log('Local cache save deferred');
        return;
    }
    
    const cacheData = {
        photos: allPhotos,
        tags: Object.keys(tagsLookup).map(name => ({ name, tagId: tagsLookup[name] })),
        galleries: galleries,
        sunData: sunData
    };
    await saveToLocalCache(cacheData);
}

async function syncPhotosToCache(photos) {
    if (!photos.length) return;
    if (accessLevel !== 'admin') { console.log('Viewer - skipping cache write'); return; }
    
    // Always update local cache
    await saveCurrentStateToLocalCache();
    
    // Sync to cloud if enabled
    if (isCacheEnabled()) {
        console.log('Syncing', photos.length, 'photos to cloud cache...');
        const result = await postToCache({ action: 'syncPhotos', photos });
        console.log('Photos synced to cloud:', result);
        return result;
    }
}

async function syncTagsToCache(tags) {
    if (!tags.length) return;
    if (accessLevel !== 'admin') return;
    
    // Always update local cache
    await saveCurrentStateToLocalCache();
    
    // Sync to cloud if enabled
    if (isCacheEnabled()) {
        const result = await postToCache({ action: 'syncTags', tags });
        console.log('Tags synced to cloud:', result);
    }
}

async function syncGalleriesToCache(galleriesData) {
    if (!galleriesData.length) return;
    if (accessLevel !== 'admin') return;
    
    // Always update local cache
    await saveCurrentStateToLocalCache();
    
    // Sync to cloud if enabled
    if (isCacheEnabled()) {
        const result = await postToCache({ action: 'syncGalleries', galleries: galleriesData });
        console.log('Galleries synced to cloud:', result);
    }
}

async function updatePhotoCacheAfterTagChange(photoId, tagIds) {
    if (accessLevel !== 'admin') return;
    
    // Always update local cache
    await saveCurrentStateToLocalCache();
    
    // Sync to cloud if enabled
    if (isCacheEnabled()) {
        await postToCache({ action: 'updatePhoto', photoId, updates: { tagIds } });
    }
}

async function updatePhotoCacheAfterGalleryChange(photoId, photoGroupIds) {
    if (accessLevel !== 'admin') return;
    
    // Always update local cache
    await saveCurrentStateToLocalCache();
    
    // Sync to cloud if enabled
    if (isCacheEnabled()) {
        await postToCache({ action: 'updatePhoto', photoId, updates: { photoGroupIds } });
    }
}

async function deletePhotoFromCache(photoId) {
    if (accessLevel !== 'admin') return;
    
    // Always update local cache
    await saveCurrentStateToLocalCache();
    
    // Sync to cloud if enabled
    if (isCacheEnabled()) {
        await postToCache({ action: 'deletePhoto', photoId });
    }
}

async function deletePhotosFromCache(photoIds) {
    if (!photoIds.length) return;
    if (accessLevel !== 'admin') return;
    
    // Always update local cache
    await saveCurrentStateToLocalCache();
    
    // Sync to cloud if enabled
    if (isCacheEnabled()) {
        await postToCache({ action: 'deletePhotos', photoIds });
    }
}

async function syncSunDataToCache(sunDataToSync) {
    if (Object.keys(sunDataToSync).length === 0) return;
    if (accessLevel !== 'admin') return;
    
    // Always update local cache with sun data
    updateLocalCacheSunData(sunDataToSync);
    
    // Sync to cloud if enabled
    if (isCacheEnabled()) {
        const result = await postToCache({ action: 'syncSunData', sunData: sunDataToSync });
        console.log('Sun data synced to cloud:', result);
    }
}

async function syncMoonDataToCache(moonDataToSync) {
    // Moon data is now included in sunData, but keep for backwards compatibility
    if (Object.keys(moonDataToSync).length === 0) return;
    if (accessLevel !== 'admin') return;
    
    // Sync to cloud if enabled
    if (isCacheEnabled()) {
        const result = await postToCache({ action: 'syncMoonData', moonData: moonDataToSync });
        console.log('Moon data synced to cloud:', result);
    }
}

// Force sync current state to cloud backup
async function syncToCloudBackup() {
    if (!isCacheEnabled()) {
        alert('Cloud backup is not configured');
        return;
    }
    if (accessLevel !== 'admin') {
        alert('Only admin can sync to cloud');
        return;
    }
    
    showLoading('Syncing to cloud backup...');
    
    try {
        // Sync all data to cloud
        await postToCache({ action: 'syncPhotos', photos: allPhotos });
        await postToCache({ action: 'syncTags', tags: Object.keys(tagsLookup).map(name => ({ name, tagId: tagsLookup[name] })) });
        await postToCache({ action: 'syncGalleries', galleries: galleries });
        await postToCache({ action: 'syncSunData', sunData: sunData });
        
        hideLoading();
        alert('Successfully synced to cloud backup!');
    } catch (e) {
        hideLoading();
        alert('Cloud sync failed: ' + e.message);
    }
}

// Clear local cache and reload from cloud
async function confirmClearCache() {
    if (!confirm('Clear local cache and reload from cloud backup?\n\nThis will remove all locally cached data.')) {
        return;
    }
    
    await clearLocalCache();
    
    if (isCacheEnabled()) {
        showLoading('Reloading from cloud...');
        const cloudData = await loadFromCloudCache();
        if (cloudData && cloudData.photos) {
            await saveToLocalCache(cloudData);
            alert('Reloaded from cloud backup. Refreshing page...');
            location.reload();
        } else {
            hideLoading();
            alert('Could not load from cloud. Please login again.');
        }
    } else {
        alert('Local cache cleared. Please login again to reload data.');
        location.reload();
    }
}

// Full refresh - clear ALL caches and rebuild from Reveal API
async function fullRefresh() {
    if (!confirm(' FULL REFRESH\n\nThis will:\n Clear local cache\n Clear cloud cache\n Reload ALL data from Reveal API\n Recalculate ALL sun/moon data\n\nThis may take a minute. Continue?')) {
        return;
    }
    
    if (accessLevel !== 'admin') {
        alert('Only admin can perform full refresh');
        return;
    }
    
    try {
        // 1. Clear local cache
        showLoading('Clearing local cache...');
        await clearLocalCache();
        
        // 2. Clear cloud cache (if enabled)
        if (isCacheEnabled()) {
            showLoading('Clearing cloud cache...');
            await postToCache({ action: 'clearAll' });
        }
        
        // 3. Clear in-memory data
        showLoading('Clearing memory...');
        allPhotos = [];
        filteredPhotos = [];
        sunData = {};
        Object.keys(tagsLookup).forEach(k => delete tagsLookup[k]);
        Object.keys(tagIdToName).forEach(k => delete tagIdToName[k]);
        Object.keys(groupsLookup).forEach(k => delete groupsLookup[k]);
        galleries = [];
        cameras.clear();
        dashboardPhotos = [];
        
        // 4. Reload from Reveal API
        showLoading('Loading from Reveal API...');
        await loadFromAPI();
        
        // 5. Recalculate ALL sun/moon data (force recalc by clearing sunData first)
        showLoading('Calculating sun/moon data...');
        sunData = {}; // Force recalculation
        await prefetchSunData();
        
        // 6. Save to local cache
        showLoading('Saving to local cache...');
        await saveCurrentStateToLocalCache();
        
        // 7. Save to cloud cache
        if (isCacheEnabled()) {
            showLoading('Saving to cloud cache...');
            await postToCache({ action: 'syncPhotos', photos: allPhotos });
            await postToCache({ action: 'syncTags', tags: Object.keys(tagsLookup).map(name => ({ name, tagId: tagsLookup[name] })) });
            await postToCache({ action: 'syncGalleries', galleries: galleries });
            await postToCache({ action: 'syncSunData', sunData: sunData });
        }
        
        // 8. Rebuild dashboard
        showLoading('Rebuilding dashboard...');
        await processPhotosForPrediction();
        await prefetchForecast();
        
        hideLoading();
        await updateCacheStatus();
        
        alert(' Full refresh complete!\n\n ' + allPhotos.length + ' photos loaded\n ' + Object.keys(sunData).length + ' dates calculated\n\nRefreshing page...');
        location.reload();
        
    } catch (e) {
        hideLoading();
        console.error('Full refresh error:', e);
        alert('Full refresh failed: ' + e.message + '\n\nPlease try logging in again.');
    }
}

// Update cache status indicator
async function updateCacheStatus() {
    console.log('updateCacheStatus called, accessLevel:', accessLevel);
    
    const statusEl = document.getElementById('cacheStatus');
    const statusText = document.getElementById('cacheStatusText');
    const cloudBtn = document.getElementById('cloudSyncBtn');
    const fullRefreshBtn = document.getElementById('fullRefreshBtn');
    
    if (!statusEl) {
        console.log('cacheStatus element not found');
        return;
    }
    
    const localCache = await loadFromLocalCache();
    const hasLocal = localCache && localCache.photos && localCache.photos.length > 0;
    const hasCloud = isCacheEnabled();
    
    console.log('Cache status - hasLocal:', hasLocal, 'hasCloud:', hasCloud);
    
    if (accessLevel === 'admin') {
        console.log('Showing admin cache buttons');
        statusEl.style.display = 'inline';
        fullRefreshBtn.style.display = 'inline-block';
        
        if (hasLocal && hasCloud) {
            statusText.textContent = 'Local + Cloud';
            statusText.className = '';
            cloudBtn.style.display = 'inline-block';
        } else if (hasLocal) {
            statusText.textContent = 'Local Only';
            statusText.className = 'text-warning';
            cloudBtn.style.display = hasCloud ? 'inline-block' : 'none';
        } else if (hasCloud) {
            statusText.textContent = 'Cloud Only';
            statusText.className = 'text-info';
            cloudBtn.style.display = 'none';
        } else {
            statusText.textContent = 'No Cache';
            statusText.className = 'text-danger';
            cloudBtn.style.display = 'none';
        }
    } else {
        console.log('Not admin, hiding cache buttons');
    }
}

async function initializeApp() {
    const savedEmail = localStorage.getItem('trailcam_email');
    const displayName = savedEmail === 'QuickView' ? 'Quick View' : (savedEmail || 'User');
    document.getElementById('userName').textContent = displayName;
    document.getElementById('userDisplay').style.display = 'inline';
    document.getElementById('logoutBtn').style.display = 'inline-block';
    document.getElementById('mainContent').style.display = 'block';
    document.getElementById('mainTabs').style.display = 'flex';
    document.getElementById('filterBar').style.display = 'block';
    
    // Initialize modals
    galleryModalInstance = new bootstrap.Modal(document.getElementById('galleryModal'));
    bulkGalleryModalInstance = new bootstrap.Modal(document.getElementById('bulkGalleryModal'));
    bulkDeleteModalInstance = new bootstrap.Modal(document.getElementById('bulkDeleteModal'));
    rapidFireModalInstance = new bootstrap.Modal(document.getElementById('rapidFireModal'));
    
    // Decide whether to use cache:
    // - Admin: use cache
    // - QuickView: use cache (same account, same data)
    // - Viewer with own login: skip cache (their data is different)
    const useCache = accessLevel === 'admin' || savedEmail === 'QuickView';
    console.log('=== initializeApp cache decision ===');
    console.log('accessLevel:', accessLevel, 'savedEmail:', savedEmail, 'useCache:', useCache);
    
    // Try loading from cache first
    const cachedData = useCache ? await loadFromCache() : null;
    
    if (cachedData && cachedData.photos && cachedData.photos.length > 0) {
        // Use cached data
        showLoading('Loading photos...');
        
        // Load tags
        if (cachedData.tags) {
            cachedData.tags.forEach(tag => {
                tagsLookup[tag.name] = tag.tagId;
                tagIdToName[tag.tagId] = tag.name;
            });
            populateTagFilter();
        }
        
        // Load galleries
        if (cachedData.galleries) {
            cachedData.galleries.forEach(g => {
                groupsLookup[g.photoGroupId] = g.name;
            });
            galleries = cachedData.galleries;
            populateGalleryFilter();
        }
        
        // Load sun/moon data (moon data now included in sunData, but handle legacy moonData for backwards compat)
        if (cachedData.sunData) sunData = cachedData.sunData;
        if (cachedData.moonData) {
            // Merge legacy moonData into sunData for backwards compatibility
            for (const dateStr of Object.keys(cachedData.moonData)) {
                if (sunData[dateStr]) {
                    Object.assign(sunData[dateStr], cachedData.moonData[dateStr]);
                }
            }
        }
        
        // Load photos
        allPhotos = cachedData.photos;
        cachedData.photos.forEach(p => {
            if (p.cameraName) cameras.add(p.cameraName);
            if (p.cameraLocation) locations.add(p.cameraLocation);
        });
        populateFilters();
        filteredPhotos = [...allPhotos];
        applyFilters();
        
        console.log(`Loaded ${allPhotos.length} photos from cache`);
    } else {
        // No cache - load everything from Reveal API
        await loadFromAPI();
        
        // Save to local cache for next time (if admin)
        if (accessLevel === 'admin') {
            await saveCurrentStateToLocalCache();
            console.log('Saved initial data to local cache');
        }
    }
    
    // Apply access level restrictions
    applyAccessLevel();
    
    // Hide loading - photos are visible now
    hideLoading();
    
    // Update cache status indicator
    await updateCacheStatus();
    
    // Pre-fetch sun/forecast data, then initialize dashboard
    (async () => {
        try {
            // Get GPS location from photos and reverse geocode
            await updateLocationFromPhotos();
            
            await prefetchSunData();
            await processPhotosForPrediction();
            await prefetchForecast();
            console.log('Sun/forecast data ready');
            
            // Dashboard is now default tab, initialize it
            if (!dashboardInitialized) {
                initializeDashboard();
            }
        } catch (e) {
            console.error('Prefetch error:', e);
            // Still try to initialize dashboard even if prefetch fails
            if (!dashboardInitialized) {
                initializeDashboard();
            }
        }
    })();
    
    // Dashboard tab listener (for when switching back to dashboard)
    document.getElementById('dashboard-tab').addEventListener('shown.bs.tab', () => {
        document.getElementById('sortOrder').style.display = 'none';
        document.getElementById('dayNightFilter').style.display = '';
        document.getElementById('filterBar').style.display = 'block';
        clearFilters();
        if (!dashboardInitialized) {
            initializeDashboard();
        } else {
            applyDashboardFilters();
        }
    });
    
    // Photos tab listener - clear filters and render when switching to photos
    document.getElementById('photos-tab').addEventListener('shown.bs.tab', () => {
        document.getElementById('sortOrder').style.display = '';
        document.getElementById('dayNightFilter').style.display = 'none';
        document.getElementById('filterBar').style.display = 'block';
        clearFilters();
    });
    
    // Account tab listener - hide filter bar
    document.getElementById('account-tab').addEventListener('shown.bs.tab', () => {
        document.getElementById('filterBar').style.display = 'none';
        loadAccountSettings();
    });
}

async function backgroundSyncWithReveal() {
    // Run in background - don't block UI
    console.log('Starting background sync with Reveal API...');
    
    try {
        // Get latest tags
        const tagsResponse = await fetch(`${CONFIG.apiBaseUrl}/photo-tags`, {
            headers: { 'Authorization': `Bearer ${accessToken}` }
        });
        const tagsData = await tagsResponse.json();
        if (tagsData.response && tagsData.response.photoTags) {
            const tags = tagsData.response.photoTags;
            tags.forEach(tag => {
                tagsLookup[tag.name] = tag.tagId;
                tagIdToName[tag.tagId] = tag.name;
            });
            syncTagsToCache(tags);
        }
        
        // Get latest galleries
        const galleriesResponse = await fetch(`${CONFIG.apiBaseUrl}/photo-groups`, {
            headers: { 'Authorization': `Bearer ${accessToken}` }
        });
        const galleriesData = await galleriesResponse.json();
        if (galleriesData.response && galleriesData.response.photoGroups) {
            const newGalleries = galleriesData.response.photoGroups;
            newGalleries.forEach(g => {
                groupsLookup[g.photoGroupId] = g.name;
            });
            galleries = newGalleries;
            syncGalleriesToCache(newGalleries);
        }
        
        // Check for new photos (compare with cached)
        const existingIds = new Set(allPhotos.map(p => p.photoId));
        const newPhotos = [];
        
        // Fetch recent pages to find new photos
        let page = 1;
        const maxPages = 5; // Only check first 5 pages for new photos
        
        while (page <= maxPages) {
            const url = `${CONFIG.apiBaseUrl}/photos?page=${page}&pageSize=500&sortField=photoDate&sortDirection=desc`;
            const response = await fetch(url, {
                headers: { 'Authorization': `Bearer ${accessToken}` }
            });
            const data = await response.json();
            
            if (!data.response || !data.response.photos || data.response.photos.length === 0) break;
            
            let foundExisting = false;
            for (const photo of data.response.photos) {
                if (existingIds.has(photo.photoId)) {
                    foundExisting = true;
                    // Update existing photo with latest data (tags/galleries may have changed)
                    const existingPhoto = allPhotos.find(p => p.photoId === photo.photoId);
                    if (existingPhoto) {
                        existingPhoto.tagIds = photo.tagIds;
                        existingPhoto.photoGroupIds = photo.photoGroupIds;
                    }
                } else {
                    newPhotos.push(photo);
                    existingIds.add(photo.photoId);
                }
            }
            
            // If we found existing photos, we've caught up
            if (foundExisting && page > 1) break;
            
            page++;
        }
        
        if (newPhotos.length > 0) {
            console.log(`Found ${newPhotos.length} new photos`);
            allPhotos = [...newPhotos, ...allPhotos];
            newPhotos.forEach(p => {
                if (p.cameraName) cameras.add(p.cameraName);
                if (p.cameraLocation) locations.add(p.cameraLocation);
            });
            populateFilters();
            
            // Update display
            filteredPhotos = [...allPhotos];
            applyFilters();
            
            // Sync new photos to cache
            syncPhotosToCache(newPhotos);
        }
        
        console.log('Background sync complete');
    } catch (error) {
        console.error('Background sync error:', error);
    }
}

// ============== LOAD DATA ==============
async function loadTags() {
    const response = await fetch(`${CONFIG.apiBaseUrl}/photo-tags`, {
        headers: { 'Authorization': `Bearer ${accessToken}` }
    });
    const data = await response.json();
    
    if (data.response && data.response.photoTags) {
        data.response.photoTags.forEach(tag => {
            tagsLookup[tag.name] = tag.tagId;
            tagIdToName[tag.tagId] = tag.name;
        });
    }
    
    console.log('Tags loaded:', Object.keys(tagsLookup).length);
    console.log('tagsLookup:', tagsLookup);
    console.log('tagIdToName:', tagIdToName);
}

function populateTagFilter() {
    // Tags are used in tag buttons and dropdowns, which are hardcoded in HTML
    // This function just logs the status
    console.log('Tags populated:', Object.keys(tagsLookup).length);
}

function populateGalleryFilter() {
    const select = document.getElementById('galleryFilter');
    const current = select.value;
    select.innerHTML = '<option value="">Gallery</option>';
    galleries.forEach(g => {
        const sel = g.photoGroupId === current ? ' selected' : '';
        select.innerHTML += `<option value="${g.photoGroupId}"${sel}>${g.name} (${g.photoCount || g.count || 0})</option>`;
    });
    
    populateGalleryGrids();
}

async function loadPhotoGroups() {
    const response = await fetch(`${CONFIG.apiBaseUrl}/photoGroups?galleryType=standard`, {
        headers: { 'Authorization': `Bearer ${accessToken}` }
    });
    const data = await response.json();
    
    if (data.response && data.response.photoGroups) {
        data.response.photoGroups.forEach(group => {
            groupsLookup[group.photoGroupId] = group.name;
        });
    }
}

async function loadGalleries() {
    const response = await fetch(`${CONFIG.apiBaseUrl}/photoGroups?galleryType=standard`, {
        headers: { 'Authorization': `Bearer ${accessToken}` }
    });
    const data = await response.json();
    
    if (data.response && data.response.photoGroups) {
        galleries = data.response.photoGroups.map(g => ({
            photoGroupId: g.photoGroupId,
            name: g.name,
            photoUrl: g.photoUrl || null,
            count: g.count || 0,
            photoCount: g.count || 0
        }));
    }
    
    populateGalleryFilter();
}

async function loadPhotos() {
    showLoading('Loading photos...');
    allPhotos = [];
    cameras = new Set();
    let skippedCount = 0;
    let page = 0;
    
    while (true) { // Fetch ALL photos - cache will speed up future loads
        showLoading(`Loading photos (page ${page + 1})...`);
        
        const response = await fetch(
            `${CONFIG.apiBaseUrl}/photos?size=100&page=${page}&includeWeatherData=true`,
            { headers: { 'Authorization': `Bearer ${accessToken}` } }
        );
        
        // API returns 400 when page is out of range - that's our signal to stop
        if (!response.ok) break;
        
        const data = await response.json();
        
        if (!data.response || !data.response.photos || data.response.photos.length === 0) break;
        
        for (const photo of data.response.photos) {
            const photoDate = photo.photoDateUtc || photo.photoDate;
            if (!photoDate) { skippedCount++; continue; }
            if (photo.cameraName) cameras.add(photo.cameraName);
            if (photo.cameraLocation) locations.add(photo.cameraLocation);
            allPhotos.push(photo);
        }
        page++;
    }
    
    // Populate filters
    populateFilters();
    
    console.log(`Loaded ${allPhotos.length} photos${skippedCount > 0 ? ` (${skippedCount} skipped)` : ''}`);
    
    // Debug: check sample photos with tags
    const taggedPhotos = allPhotos.filter(p => p.tagIds && p.tagIds.length > 0);
    console.log('Photos with tags:', taggedPhotos.length);
    if (taggedPhotos.length > 0) {
        console.log('Sample tagged photo:', taggedPhotos[0]);
        console.log('Sample tagIds:', taggedPhotos[0].tagIds);
    }
    
    applyFilters();
    hideLoading();
    
    // Sync all data to cache in BACKGROUND (don't block UI)
    if (isCacheEnabled() && accessLevel === 'admin') {
        showSyncStatus('Syncing to cache...', 'syncing');
        
        // Fire and forget - don't await
        (async () => {
            try {
                // Sync tags & galleries
                const tags = Object.entries(tagsLookup).map(([name, tagId]) => ({ tagId, name }));
                await syncTagsToCache(tags);
                await syncGalleriesToCache(galleries);
                
                showSyncStatus(`Syncing ${allPhotos.length} photos...`, 'syncing');
                
                // Sync ALL photos in one request
                await syncPhotosToCache(allPhotos);
                
                showSyncStatus('Cache sync complete!', 'complete');
                setTimeout(() => hideSyncStatus(), 3000);
            } catch (e) {
                console.error('Background cache sync error:', e);
                showSyncStatus('Sync error', 'error');
                setTimeout(() => hideSyncStatus(), 5000);
            }
        })();
    }
}

function populateFilters() {
    const cameraSelect = document.getElementById('cameraFilter');
    cameraSelect.innerHTML = '<option value="">Cameras</option>';
    Array.from(cameras).sort().forEach(cam => {
        cameraSelect.innerHTML += `<option value="${cam}">${cam}</option>`;
    });
    
    const locationSelect = document.getElementById('locationFilter');
    locationSelect.innerHTML = '<option value="">Locations</option>';
    Array.from(locations).sort().forEach(loc => {
        locationSelect.innerHTML += `<option value="${loc}">${loc}</option>`;
    });
}

async function refreshPhotos() {
    showLoading('Checking for new photos...');
    
    try {
        const existingIds = new Set(allPhotos.map(p => p.photoId));
        let newPhotos = [];
        let page = 0;
        
        while (true) {
            const response = await fetch(
                `${CONFIG.apiBaseUrl}/photos?size=100&page=${page}&includeWeatherData=true`,
                { headers: { 'Authorization': `Bearer ${accessToken}` } }
            );
            const data = await response.json();
            if (!data.response || !data.response.photos || data.response.photos.length === 0) break;
            
            let foundExisting = false;
            for (const photo of data.response.photos) {
                if (existingIds.has(photo.photoId)) { foundExisting = true; continue; }
                if (!photo.photoDateUtc && !photo.photoDate) continue;
                if (photo.cameraName) cameras.add(photo.cameraName);
                if (photo.cameraLocation) locations.add(photo.cameraLocation);
                allPhotos.unshift(photo);
                newPhotos.push(photo);
            }
            if (foundExisting) break;
            page++;
        }
        
        populateFilters();
        await loadGalleries();
        applyFilters();
        hideLoading();
        
        // Show most recent photo in tooltip
        showMostRecentInTooltip();
        
        // Sync new photos to cache in background
        if (newPhotos.length > 0) {
            showSyncStatus(`Syncing ${newPhotos.length} new photos...`, 'syncing');
            syncPhotosToCache(newPhotos).then(() => {
                showSyncStatus(`${newPhotos.length} new photos synced!`, 'complete');
                setTimeout(() => hideSyncStatus(), 3000);
            }).catch(() => {
                showSyncStatus('Sync error', 'error');
                setTimeout(() => hideSyncStatus(), 5000);
            });
        }
        
        console.log(newPhotos.length > 0 ? `Added ${newPhotos.length} new photos` : 'No new photos');
    } catch (error) {
        hideLoading();
        console.error('Refresh error:', error);
        alert('Could not connect to Reveal API. Try using the local batch file to sync new photos.');
    }
}

// ============== FILTERS ==============
function applyFilters() {
    const locationFilter = document.getElementById('locationFilter').value;
    const cameraFilter = document.getElementById('cameraFilter').value;
    const tagFilter = document.getElementById('tagFilter').value;
    const galleryFilter = document.getElementById('galleryFilter').value;
    const sortOrder = document.getElementById('sortOrder').value;
    
    // Sort allPhotos by date
    allPhotos.sort((a, b) => {
        const dateA = new Date(a.photoDateUtc || a.photoDate || 0);
        const dateB = new Date(b.photoDateUtc || b.photoDate || 0);
        return sortOrder === 'newest' ? dateB - dateA : dateA - dateB;
    });
    
    filteredPhotos = allPhotos.filter(photo => {
        if (locationFilter && photo.cameraLocation !== locationFilter) return false;
        if (cameraFilter && photo.cameraName !== cameraFilter) return false;
        if (galleryFilter && (!photo.photoGroupIds || !photo.photoGroupIds.includes(galleryFilter))) return false;
        if (tagFilter === 'untagged') {
            if (photo.tagIds && photo.tagIds.length > 0) return false;
        } else if (tagFilter) {
            const tagId = tagsLookup[tagFilter];
            if (!tagId || !photo.tagIds || !photo.tagIds.includes(tagId)) return false;
        }
        return true;
    });
    
    currentIndex = 0;
    gridDisplayCount = 100;
    renderGrid();
    updateBulkActionBar();
    updatePhotoCount();
    
    // Also update dashboard charts if on dashboard tab
    if (document.getElementById('dashboardContent').classList.contains('active')) {
        applyDashboardFilters();
    }
}

function clearFilters() {
    document.getElementById('locationFilter').value = '';
    document.getElementById('cameraFilter').value = '';
    document.getElementById('tagFilter').value = '';
    document.getElementById('galleryFilter').value = '';
    document.getElementById('dayNightFilter').value = '';
    document.getElementById('sortOrder').value = 'newest';
    applyFilters();
}

// ============== PHOTO DISPLAY ==============
function getPhotoDate(photo) {
    return photo.photoDateUtc || photo.photoDate || photo.createdAt || null;
}

function formatDate(utc) {
    if (!utc) return '--';
    return new Date(utc).toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
}

function formatTime(utc) {
    if (!utc) return '--';
    return new Date(utc).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
}

// ============== GRID VIEW ==============
let gridObserver = null;

function renderGrid() {
    const grid = document.getElementById('photoGrid');
    const loadMore = document.getElementById('gridLoadMore');
    
    // Disconnect previous observer
    if (gridObserver) gridObserver.disconnect();
    
    if (filteredPhotos.length === 0) {
        grid.innerHTML = '<div class="col-12 text-center py-5 text-muted">No photos match filter.</div>';
        loadMore.style.display = 'none';
        return;
    }
    
    grid.innerHTML = filteredPhotos.slice(0, gridDisplayCount).map((photo, index) => {
        const isSelected = selectedPhotos.has(photo.photoId);
        const tagName = photo.tagIds && photo.tagIds.length > 0 ? tagIdToName[photo.tagIds[0]] || '' : 'Untagged';
        const photoDate = getPhotoDate(photo);
        
        let galleryNames = [];
        if (photo.photoGroupIds) {
            photo.photoGroupIds.forEach(id => { if (groupsLookup[id]) galleryNames.push(groupsLookup[id]); });
        }
        const galleryDisplay = galleryNames.join(', ');
        
        return `
            <div class="grid-item ${isSelected ? 'selected' : ''}" data-photo-id="${photo.photoId}" onclick="togglePhotoSelection('${photo.photoId}', event)">
                <div class="grid-item-checkbox">${isSelected ? '' : ''}</div>
                <img class="grid-item-img" src="${photo.photoUrl}" loading="lazy" />
                <div class="grid-zoom-overlay" onclick="openZoomModal(${index}, event)">Zoom</div>
                <div class="grid-item-info">
                    <div class="camera">${photo.cameraName || 'Unknown'}</div>
                    <div>${formatDate(photoDate)} ${formatTime(photoDate)}</div>
                    <div>
                        <span class="tag">${tagName}</span>
                        ${galleryDisplay ? `<span class="gallery ms-2"><img class="gallery-icon" src="https://png.pngtree.com/png-vector/20230729/ourmid/pngtree-whitetail-buck-vector-png-image_7006974.png" /> ${galleryDisplay}</span>` : ''}
                    </div>
                </div>
            </div>
        `;
    }).join('');
    
    // Hide load more button (using infinite scroll instead)
    loadMore.style.display = 'none';
    
    // Set up infinite scroll observer on last item
    setupGridObserver();
}

function setupGridObserver() {
    const items = document.querySelectorAll('.grid-item');
    if (items.length === 0 || gridDisplayCount >= filteredPhotos.length) return;
    
    // Observe the last item
    const lastItem = items[items.length - 1];
    
    gridObserver = new IntersectionObserver((entries) => {
        if (entries[0].isIntersecting) {
            loadMoreGridItems();
        }
    }, { rootMargin: '100px' });
    
    gridObserver.observe(lastItem);
}

function loadMoreGridItems() { gridDisplayCount += 100; renderGrid(); }

// ============== SELECTION ==============
function togglePhotoSelection(id, e) {
    if (e) e.stopPropagation();
    selectedPhotos.has(id) ? selectedPhotos.delete(id) : selectedPhotos.add(id);
    const item = document.querySelector(`[data-photo-id="${id}"]`);
    if (item) {
        item.classList.toggle('selected');
        item.querySelector('.grid-item-checkbox').textContent = selectedPhotos.has(id) ? '' : '';
    }
    updateBulkActionBar();
}

function clearSelection() {
    selectedPhotos.clear();
    document.querySelectorAll('.grid-item.selected').forEach(el => {
        el.classList.remove('selected');
        el.querySelector('.grid-item-checkbox').textContent = '';
    });
    updateBulkActionBar();
}

function selectAll() {
    filteredPhotos.slice(0, gridDisplayCount).forEach(p => selectedPhotos.add(p.photoId));
    renderGrid();
    updateBulkActionBar();
}

function selectUntagged() {
    const untagged = filteredPhotos.slice(0, gridDisplayCount).filter(p => !p.tagIds || p.tagIds.length === 0);
    const allSelected = untagged.length > 0 && untagged.every(p => selectedPhotos.has(p.photoId));
    if (allSelected) clearSelection();
    else { untagged.forEach(p => selectedPhotos.add(p.photoId)); renderGrid(); updateBulkActionBar(); }
}

function toggleSelectAll() {
    const visible = Math.min(gridDisplayCount, filteredPhotos.length);
    selectedPhotos.size >= visible && visible > 0 ? clearSelection() : selectAll();
}

function updateBulkActionBar() {
    const count = selectedPhotos.size;
    const visible = Math.min(gridDisplayCount, filteredPhotos.length);
    const allSelected = count >= visible && visible > 0;
    const untagged = filteredPhotos.slice(0, gridDisplayCount).filter(p => !p.tagIds || p.tagIds.length === 0);
    const allUntaggedSelected = untagged.length > 0 && untagged.every(p => selectedPhotos.has(p.photoId));
    
    const countEl = document.getElementById('gridSelectedCount');
    countEl.textContent = count > 0 ? `${count} selected` : 'None selected';
    countEl.style.color = count > 0 ? 'var(--accent-green)' : 'rgba(255,255,255,0.5)';
    
    const toggleBtn = document.getElementById('selectToggleBtn');
    toggleBtn.textContent = allSelected ? 'Clear All' : 'Select All';
    toggleBtn.className = allSelected ? 'btn btn-secondary btn-sm' : 'btn btn-primary btn-sm';
    const untaggedBtn = document.getElementById('selectUntaggedBtn');
    untaggedBtn.textContent = allUntaggedSelected ? 'Clear' : 'Select Untagged';
    untaggedBtn.className = allUntaggedSelected ? 'btn btn-secondary btn-sm' : 'btn btn-warning btn-sm';
    
    // Enable/disable bulk action buttons based on selection
    const hasSelection = count > 0;
    document.getElementById('bulkTagDropdown').disabled = !hasSelection;
    document.getElementById('bulkGalleryBtn').disabled = !hasSelection;
    document.getElementById('bulkDownloadBtn').disabled = !hasSelection;
    document.getElementById('bulkDeleteBtn').disabled = !hasSelection;
}

// ============== TAGGING ==============
function bulkTagFromDropdown() {
    const val = document.getElementById('bulkTagDropdown').value;
    if (val && selectedPhotos.size > 0) { bulkTagPhotos(val); document.getElementById('bulkTagDropdown').value = ''; }
}

async function bulkTagPhotos(tagName) {
    const isClearing = tagName === '__none__';
    const tagId = isClearing ? null : tagsLookup[tagName];
    if (!isClearing && !tagId) return;
    
    const newTagIds = isClearing ? [] : [tagId];
    showLoading(`Tagging ${selectedPhotos.size} photos...`);
    for (const photoId of selectedPhotos) {
        try {
            await fetch(`${CONFIG.apiBaseUrl}/photos/${photoId}`, {
                method: 'PUT',
                headers: { 'Authorization': `Bearer ${accessToken}`, 'Content-Type': 'application/json' },
                body: JSON.stringify({ tagIds: newTagIds })
            });
            const photo = allPhotos.find(p => p.photoId === photoId);
            if (photo) photo.tagIds = newTagIds;
            
            // Sync to cache
            updatePhotoCacheAfterTagChange(photoId, newTagIds);
        } catch (e) {}
    }
    hideLoading();
    clearSelection();
    renderGrid();
    
}

// ============== GALLERIES ==============
function populateGalleryGrids() {
    const noneCard = `
        <div class="col-6 col-md-4 col-lg-3">
            <div class="card h-100" style="cursor:pointer;" onclick="clearGalleryFromModal()">
                <div class="card-img-top d-flex align-items-center justify-content-center" style="height:100px;background:#333;">
                    <i class="bi bi-x-circle text-danger" style="font-size:2rem;"></i>
                </div>
                <div class="card-body py-2">
                    <div class="card-title mb-0 small" style="color: var(--text-muted);">None</div>
                    <small class="text-light">Clear gallery</small>
                </div>
            </div>
        </div>
    `;
    
    const galleryCards = galleries.map(g => `
        <div class="col-6 col-md-4 col-lg-3">
            <div class="card h-100" style="cursor:pointer;" onclick="selectGalleryFromModal('${g.photoGroupId}')">
                ${g.photoUrl ? `<img src="${g.photoUrl}" class="card-img-top" style="height:100px;object-fit:cover;">` : `<div class="card-img-top d-flex align-items-center justify-content-center" style="height:100px;background:#333;"><i class="bi bi-folder text-muted" style="font-size:2rem;"></i></div>`}
                <div class="card-body py-2">
                    <div class="card-title mb-0 small" style="color: var(--accent-green);">${g.name}</div>
                    <small class="text-light">${g.count} photos</small>
                </div>
            </div>
        </div>
    `).join('');
    
    const html = noneCard + galleryCards;
    document.getElementById('galleryGrid').innerHTML = html;
    document.getElementById('bulkGalleryGrid').innerHTML = html.replace(/selectGalleryFromModal/g, 'bulkAddToGallery').replace(/clearGalleryFromModal/g, 'bulkClearGallery');
}

function openGalleryModal() { 
    if (filteredPhotos.length > 0) {
        const galleryEl = document.getElementById('galleryModal');
        if (zoomModalOpen) {
            galleryEl.classList.add('from-zoom');
            // Hide backdrop when opening from zoom modal
            galleryEl.addEventListener('shown.bs.modal', function handler() {
                const backdrops = document.querySelectorAll('.modal-backdrop');
                if (backdrops.length > 0) {
                    backdrops[backdrops.length - 1].style.opacity = '0';
                }
                galleryEl.removeEventListener('shown.bs.modal', handler);
            });
        } else {
            galleryEl.classList.remove('from-zoom');
        }
        galleryModalInstance.show();
    }
}
function openBulkGalleryModal() { 
    if (selectedPhotos.size > 0) {
        const galleryEl = document.getElementById('bulkGalleryModal');
        // Hide backdrop for bulk gallery modal
        galleryEl.addEventListener('shown.bs.modal', function handler() {
            const backdrops = document.querySelectorAll('.modal-backdrop');
            if (backdrops.length > 0) {
                backdrops[backdrops.length - 1].style.opacity = '0';
            }
            galleryEl.removeEventListener('shown.bs.modal', handler);
        });
        bulkGalleryModalInstance.show();
    }
}

async function selectGalleryFromModal(galleryId) {
    const photo = filteredPhotos[zoomIndex];
    galleryModalInstance.hide();
    showLoading('Adding to gallery...');
    try {
        await fetch(`${CONFIG.apiBaseUrl}/photoGroups/${galleryId}/batchAdd`, {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${accessToken}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({ photoIds: [photo.photoId] })
        });
        if (!photo.photoGroupIds) photo.photoGroupIds = [];
        if (!photo.photoGroupIds.includes(galleryId)) photo.photoGroupIds.push(galleryId);
        await loadGalleries();
        updateZoomModal();
        renderGrid();
        
        // Sync to cache
        updatePhotoCacheAfterGalleryChange(photo.photoId, photo.photoGroupIds);
    } catch (e) { alert('Error: ' + e.message); }
    hideLoading();
}

async function bulkAddToGallery(galleryId) {
    bulkGalleryModalInstance.hide();
    showLoading(`Adding ${selectedPhotos.size} photos to gallery...`);
    try {
        await fetch(`${CONFIG.apiBaseUrl}/photoGroups/${galleryId}/batchAdd`, {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${accessToken}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({ photoIds: Array.from(selectedPhotos) })
        });
        for (const id of selectedPhotos) {
            const photo = allPhotos.find(p => p.photoId === id);
            if (photo) {
                if (!photo.photoGroupIds) photo.photoGroupIds = [];
                if (!photo.photoGroupIds.includes(galleryId)) photo.photoGroupIds.push(galleryId);
                
                // Sync to cache
                updatePhotoCacheAfterGalleryChange(id, photo.photoGroupIds);
            }
        }
        await loadGalleries();
        clearSelection();
        renderGrid();
    } catch (e) { alert('Error: ' + e.message); }
    hideLoading();
}

async function clearGalleryFromModal() {
    const photo = filteredPhotos[zoomIndex];
    galleryModalInstance.hide();
    
    if (!photo.photoGroupIds || photo.photoGroupIds.length === 0) {
        return; // Already not in any gallery
    }
    
    showLoading('Removing from galleries...');
    try {
        // Remove from all galleries the photo is in
        for (const galleryId of photo.photoGroupIds) {
            await fetch(`${CONFIG.apiBaseUrl}/photoGroups/${galleryId}/batchDelete`, {
                method: 'DELETE',
                headers: { 'Authorization': `Bearer ${accessToken}`, 'Content-Type': 'application/json' },
                body: JSON.stringify({ photoIds: [photo.photoId] })
            });
        }
        photo.photoGroupIds = [];
        await loadGalleries();
        updateZoomModal();
        renderGrid();
        
        // Sync to cache
        updatePhotoCacheAfterGalleryChange(photo.photoId, []);
    } catch (e) { alert('Error: ' + e.message); }
    hideLoading();
}

async function bulkClearGallery() {
    bulkGalleryModalInstance.hide();
    showLoading(`Removing ${selectedPhotos.size} photos from galleries...`);
    try {
        // Group photos by their galleries
        const galleryToPhotos = {};
        for (const id of selectedPhotos) {
            const photo = allPhotos.find(p => p.photoId === id);
            if (photo && photo.photoGroupIds) {
                for (const galleryId of photo.photoGroupIds) {
                    if (!galleryToPhotos[galleryId]) galleryToPhotos[galleryId] = [];
                    galleryToPhotos[galleryId].push(id);
                }
            }
        }
        
        // Remove photos from each gallery
        for (const [galleryId, photoIds] of Object.entries(galleryToPhotos)) {
            await fetch(`${CONFIG.apiBaseUrl}/photoGroups/${galleryId}/batchDelete`, {
                method: 'DELETE',
                headers: { 'Authorization': `Bearer ${accessToken}`, 'Content-Type': 'application/json' },
                body: JSON.stringify({ photoIds })
            });
        }
        
        // Update local data
        for (const id of selectedPhotos) {
            const photo = allPhotos.find(p => p.photoId === id);
            if (photo) {
                photo.photoGroupIds = [];
                updatePhotoCacheAfterGalleryChange(id, []);
            }
        }
        
        await loadGalleries();
        clearSelection();
        renderGrid();
    } catch (e) { alert('Error: ' + e.message); }
    hideLoading();
}

// ============== DELETE ==============
function openBulkDeleteModal() { if (selectedPhotos.size > 0) { document.getElementById('bulkDeleteCount').textContent = selectedPhotos.size; bulkDeleteModalInstance.show(); } }

async function confirmBulkDelete() {
    bulkDeleteModalInstance.hide();
    const photoIds = Array.from(selectedPhotos);
    showLoading(`Deleting ${photoIds.length} photos...`);
    
    for (const id of photoIds) {
        try {
            await fetch(`${CONFIG.apiBaseUrl}/photos/${id}`, { method: 'DELETE', headers: { 'Authorization': `Bearer ${accessToken}` } });
            const idx = allPhotos.findIndex(p => p.photoId === id);
            if (idx !== -1) allPhotos.splice(idx, 1);
        } catch (e) {}
    }
    
    // Bulk sync to cache
    deletePhotosFromCache(photoIds);
    
    hideLoading();
    clearSelection();
    applyFilters();
}

async function bulkDownload() {
    if (selectedPhotos.size === 0) {
        alert('No photos selected');
        return;
    }
    
    const photos = allPhotos.filter(p => selectedPhotos.has(p.photoId));
    const total = photos.length;
    let downloaded = 0;
    let failed = 0;
    
    showLoading(`Downloading ${total} photos...`);
    
    for (const photo of photos) {
        try {
            // Use Apps Script proxy to bypass CORS
            const proxyUrl = `${CONFIG.googleSheetsUrl}?action=downloadImage&url=${encodeURIComponent(photo.photoUrl)}`;
            const response = await fetch(proxyUrl);
            const result = await response.json();
            
            if (!result.success) {
                failed++;
                continue;
            }
            
            // Decode base64 to blob
            const byteCharacters = atob(result.data);
            const byteNumbers = new Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            const blob = new Blob([byteArray], { type: result.contentType || 'image/jpeg' });
            
            // Trigger download
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const photoDate = getPhotoDate(photo);
            const dateStr = photoDate ? new Date(photoDate).toISOString().split('T')[0] : 'unknown';
            a.download = `${photo.cameraName || 'photo'}_${dateStr}_${downloaded + 1}.jpg`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            downloaded++;
            showLoading(`Downloading ${downloaded}/${total} photos...`);
            
            // Small delay between downloads
            await new Promise(r => setTimeout(r, 500));
        } catch (err) {
            console.error('Download error:', err);
            failed++;
        }
    }
    
    hideLoading();
    if (failed > 0) {
        alert(`Downloaded ${downloaded} photos. ${failed} failed.`);
    }
}

// ============== QUICK TAG ZOOM MODAL ==============
let zoomIndex = 0;
let zoomModalOpen = false;
let rapidFireEnabled = false;

function openZoomModal(index, e) {
    if (e) e.stopPropagation();
    if (filteredPhotos.length === 0) return;
    
    zoomIndex = Math.max(0, Math.min(index, filteredPhotos.length - 1));
    zoomModalOpen = true;
    document.getElementById('zoomModal').style.display = 'flex';
    renderZoomTagButtons();
    updateZoomModal();
}

function closeZoomModal() {
    zoomModalOpen = false;
    rapidFireEnabled = false;
    document.getElementById('zoomModal').style.display = 'none';
    // Reset Rapid Fire label
    const label = document.getElementById('rapidFireLabel');
    if (label) label.classList.remove('active');
    updateDeleteButtonText(false);
}

function handleRapidFireClick() {
    if (rapidFireEnabled) {
        // Turn off - no confirmation needed
        rapidFireEnabled = false;
        document.getElementById('rapidFireLabel').classList.remove('active');
        updateDeleteButtonText(false);
    } else {
        // Show warning modal when enabling
        rapidFireModalInstance.show();
    }
}

function confirmRapidFire() {
    rapidFireModalInstance.hide();
    rapidFireEnabled = true;
    document.getElementById('rapidFireLabel').classList.add('active');
    updateDeleteButtonText(true);
}

function cancelRapidFire() {
    rapidFireModalInstance.hide();
}

function updateDeleteButtonText(rapidMode) {
    const btn = document.getElementById('zoomDeleteBtn');
    if (btn) {
        btn.innerHTML = rapidMode 
            ? '<i class="bi bi-trash"></i> Rapid Delete' 
            : '<i class="bi bi-trash"></i> Delete';
    }
}

function zoomPrev() {
    if (zoomIndex > 0) {
        zoomIndex--;
        updateZoomModal();
    }
}

function zoomNext() {
    if (zoomIndex < filteredPhotos.length - 1) {
        zoomIndex++;
        updateZoomModal();
    } else {
        // End of photos
        closeZoomModal();
    }
}

function updateZoomModal() {
    const photo = filteredPhotos[zoomIndex];
    if (!photo) return;
    
    // Update image
    document.getElementById('zoomImage').src = photo.photoUrl;
    
    // Update progress bar
    const pct = ((zoomIndex + 1) / filteredPhotos.length) * 100;
    document.getElementById('zoomProgress').style.width = pct + '%';
    
    // Update nav zone states
    document.getElementById('zoomNavLeft').classList.toggle('disabled', zoomIndex === 0);
    document.getElementById('zoomNavRight').classList.toggle('disabled', zoomIndex === filteredPhotos.length - 1);
    
    // Build info panel (matching tooltip panel format)
    const photoDate = getPhotoDate(photo);
    let infoHtml = '<div class="zoom-info-text">';
    
    // Line 1: Location | Camera | Date | Time
    infoHtml += '<div class="info-line">';
    infoHtml += `<span class="info-label">Location:</span> <span class="info-value">${photo.cameraLocation || 'Unknown'}</span>`;
    infoHtml += `<span class="info-sep">|</span>`;
    infoHtml += `<span class="info-label">Camera:</span> <span class="info-value">${photo.cameraName || 'Unknown'}</span>`;
    infoHtml += `<span class="info-sep">|</span>`;
    infoHtml += `<span class="info-label">Date:</span> <span class="info-value">${formatDate(photoDate)}</span>`;
    infoHtml += `<span class="info-sep">|</span>`;
    infoHtml += `<span class="info-label">Time:</span> <span class="info-value">${formatTime(photoDate)}</span>`;
    infoHtml += '</div>';
    
    // Line 2: Wind | Gallery (if assigned)
    infoHtml += '<div class="info-line">';
    if (photo.weatherData) {
        const wind = photo.weatherData.windSpeed;
        const windDir = photo.weatherData.windDirection;
        if (wind !== undefined && windDir !== undefined) {
            infoHtml += `<span class="info-label">Wind:</span> <span class="info-value">${getWindDirection(windDir)} at ${wind.toFixed(1)}mph</span>`;
        }
    }
    
    // Gallery info - only show if photo has galleries
    const photoGalleryNames = (photo.photoGroupIds || []).map(id => {
        const gallery = galleries.find(g => g.photoGroupId === id);
        return gallery ? gallery.name : null;
    }).filter(Boolean);
    
    if (photoGalleryNames.length > 0) {
        if (photo.weatherData?.windSpeed !== undefined) {
            infoHtml += `<span class="info-sep">|</span>`;
        }
        infoHtml += `<span class="info-label">Gallery:</span> <span class="info-name">${photoGalleryNames.join(', ')}</span>`;
    }
    
    infoHtml += '</div>';
    infoHtml += '</div>';
    
    // Delete button on right
    const deleteText = rapidFireEnabled ? 'Rapid Delete' : 'Delete';
    infoHtml += `<div class="zoom-delete-section">`;
    infoHtml += `<button class="zoom-delete-btn" id="zoomDeleteBtn" onclick="zoomDeletePhoto()"><i class="bi bi-trash"></i> ${deleteText}</button>`;
    infoHtml += `</div>`;
    
    document.getElementById('zoomInfo').innerHTML = infoHtml;
    
    // Update tag button states
    updateZoomTagButtonStates(photo);
    
    // Update gallery button state
    const galleryBtn = document.getElementById('zoomGalleryBtn');
    if (galleryBtn) {
        if (photoGalleryNames.length > 0) {
            galleryBtn.classList.add('active');
        } else {
            galleryBtn.classList.remove('active');
        }
    }
}

function renderZoomTagButtons() {
    const actionsDiv = document.getElementById('zoomActions');
    let html = '';
    
    // Icon mapping for known tags (matches dropdown)
    const tagIcons = {
        'Buck': '',
        'Doe': '',
        'Turkey': '',
        'Bear': '',
        'Predator': '',
        'Bird': '',
        'Human': '',
        'Vehicle/ATV': '',
        'Other': '',
        'No Animals': '',
        'Squirrel': '',
        'Raccoon': '',
        'Junk': ''
    };
    
    // Specific tag order for rows
    const topRow = ['Bird', 'Turkey', 'Bear', 'Predator', 'Doe', 'Buck'];
    const bottomRow = ['Other', 'No Animals', 'Vehicle/ATV', 'Human'];
    
    // First row of tags
    html += '<div class="zoom-tag-row">';
    topRow.forEach(tagName => {
        if (tagsLookup[tagName]) {
            const icon = tagIcons[tagName] || '';
            html += `<button class="zoom-tag-btn" data-tag="${tagName}" onclick="zoomTagPhoto('${tagName}')">${icon} ${tagName}</button>`;
        }
    });
    html += '</div>';
    
    // Second row of tags (None first for right-to-left order)
    html += '<div class="zoom-tag-row">';
    // None button to clear tags
    html += `<button class="zoom-tag-btn zoom-none-btn" data-tag="__none__" onclick="zoomClearTag()"> None</button>`;
    bottomRow.forEach(tagName => {
        if (tagsLookup[tagName]) {
            const icon = tagIcons[tagName] || '';
            html += `<button class="zoom-tag-btn" data-tag="${tagName}" onclick="zoomTagPhoto('${tagName}')">${icon} ${tagName}</button>`;
        }
    });
    html += '</div>';
    
    actionsDiv.innerHTML = html;
}

function updateZoomTagButtonStates(photo) {
    const photoTagIds = photo.tagIds || [];
    const buttons = document.querySelectorAll('#zoomActions .zoom-tag-btn[data-tag]');
    
    buttons.forEach(btn => {
        const tagName = btn.getAttribute('data-tag');
        const tagId = tagsLookup[tagName];
        if (tagId && photoTagIds.includes(tagId)) {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
    });
}

async function zoomClearTag() {
    const photo = filteredPhotos[zoomIndex];
    if (!photo) return;
    
    try {
        const response = await fetch(`${CONFIG.apiBaseUrl}/photos/${photo.photoId}`, {
            method: 'PUT',
            headers: { 
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ tagIds: [] })
        });
        
        if (response.ok) {
            photo.tagIds = [];
            const idx = allPhotos.findIndex(p => p.photoId === photo.photoId);
            if (idx !== -1) allPhotos[idx].tagIds = [];
            
            updatePhotoCacheAfterTagChange(photo.photoId, []);
            
            // Flash and advance
            document.getElementById('zoomImage').classList.add('zoom-flash');
            setTimeout(() => {
                document.getElementById('zoomImage').classList.remove('zoom-flash');
                zoomNext();
            }, 200);
            return;
        }
        
        updateZoomModal();
        renderGrid();
        
    } catch (err) {
        console.error('Error clearing tag:', err);
    }
}

async function zoomTagPhoto(tagName) {
    const photo = filteredPhotos[zoomIndex];
    if (!photo) return;
    
    const tagId = tagsLookup[tagName];
    if (!tagId) return;
    
    const currentTagIds = photo.tagIds || [];
    const alreadyHasTag = currentTagIds.includes(tagId);
    
    try {
        let newTagIds;
        if (alreadyHasTag) {
            // Remove the tag
            newTagIds = currentTagIds.filter(id => id !== tagId);
        } else {
            // Add the tag (replace existing - single tag mode)
            newTagIds = [tagId];
        }
        
        const response = await fetch(`${CONFIG.apiBaseUrl}/photos/${photo.photoId}`, {
            method: 'PUT',
            headers: { 
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ tagIds: newTagIds })
        });
        
        if (response.ok) {
            // Update photo in all arrays
            photo.tagIds = newTagIds;
            const idx = allPhotos.findIndex(p => p.photoId === photo.photoId);
            if (idx !== -1) allPhotos[idx].tagIds = newTagIds;
            
            // Sync to cache
            updatePhotoCacheAfterTagChange(photo.photoId, newTagIds);
            
            // Auto-advance only if Rapid Fire is enabled and tag was added (not removed)
            if (rapidFireEnabled && !alreadyHasTag) {
                // Flash animation and advance
                document.getElementById('zoomImage').classList.add('zoom-flash');
                setTimeout(() => {
                    document.getElementById('zoomImage').classList.remove('zoom-flash');
                    zoomNext();
                }, 200);
                return;
            }
        }
        
        updateZoomModal();
        renderGrid();
        
    } catch (err) {
        console.error('Error tagging photo:', err);
    }
}

async function zoomDownloadPhoto() {
    const photo = filteredPhotos[zoomIndex];
    if (!photo) return;
    
    const btn = document.querySelector('.zoom-download-btn');
    const originalText = btn.innerHTML;
    btn.innerHTML = '<i class="bi bi-hourglass-split"></i> Downloading...';
    btn.disabled = true;
    
    try {
        // Use Apps Script proxy to bypass CORS
        const proxyUrl = `${CONFIG.googleSheetsUrl}?action=downloadImage&url=${encodeURIComponent(photo.photoUrl)}`;
        console.log('Proxy URL:', proxyUrl);
        
        const response = await fetch(proxyUrl);
        console.log('Response status:', response.status);
        
        const text = await response.text();
        console.log('Raw response:', text.substring(0, 500));
        
        const result = JSON.parse(text);
        console.log('Parsed result:', result.success, result.error);
        
        if (!result.success) {
            throw new Error(result.error || 'Download failed');
        }
        
        // Decode base64 to blob
        const byteCharacters = atob(result.data);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        const blob = new Blob([byteArray], { type: result.contentType || 'image/jpeg' });
        
        // Trigger download
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const photoDate = getPhotoDate(photo);
        const dateStr = photoDate ? new Date(photoDate).toISOString().split('T')[0] : 'unknown';
        a.download = `${photo.cameraName || 'photo'}_${dateStr}.jpg`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    } catch (err) {
        console.error('Download error:', err);
        alert('Failed to download: ' + err.message);
    } finally {
        btn.innerHTML = originalText;
        btn.disabled = false;
    }
}

async function zoomDeletePhoto() {
    const photo = filteredPhotos[zoomIndex];
    if (!photo) return;
    
    if (!rapidFireEnabled && !confirm(`Delete this photo permanently?`)) return;
    
    try {
        const response = await fetch(`${CONFIG.apiBaseUrl}/photos/${photo.photoId}`, {
            method: 'DELETE',
            headers: { 'Authorization': `Bearer ${accessToken}` }
        });
        
        if (response.ok) {
            // Remove from all arrays
            const idx = allPhotos.findIndex(p => p.photoId === photo.photoId);
            if (idx !== -1) allPhotos.splice(idx, 1);
            filteredPhotos.splice(zoomIndex, 1);
            deletePhotoFromCache(photo.photoId);
            
            // Update grid
            renderGrid();
            updatePhotoCount();
            
            if (filteredPhotos.length === 0) {
                closeZoomModal();
            } else {
                if (zoomIndex >= filteredPhotos.length) {
                    zoomIndex = filteredPhotos.length - 1;
                }
                updateZoomModal();
            }
        }
    } catch (err) {
        console.error('Error deleting photo:', err);
        alert('Failed to delete photo');
    }
}

// ============== DASHBOARD ==============

// Store processed photos for filtering
let dashboardPhotos = [];

function populateDashboardFilters() {
    const cameras = new Set();
    const locations = new Set();
    
    dashboardPhotos.forEach(photo => {
        if (photo.camera) cameras.add(photo.camera);
        if (photo.location) locations.add(photo.location);
    });
    
    // Populate unified camera filter (if not already populated from photos)
    const cameraSelect = document.getElementById('cameraFilter');
    if (cameraSelect.options.length <= 1) {
        cameraSelect.innerHTML = '<option value="">Cameras</option>';
        Array.from(cameras).sort().forEach(cam => {
            cameraSelect.innerHTML += `<option value="${cam}">${cam}</option>`;
        });
    }
    
    // Populate unified location filter
    const locationSelect = document.getElementById('locationFilter');
    if (locationSelect.options.length <= 1) {
        locationSelect.innerHTML = '<option value="">Locations</option>';
        Array.from(locations).sort().forEach(loc => {
            locationSelect.innerHTML += `<option value="${loc}">${loc}</option>`;
        });
    }
}

function applyDashboardFilters() {
    const cameraFilter = document.getElementById('cameraFilter').value;
    const locationFilter = document.getElementById('locationFilter').value;
    const tagFilter = document.getElementById('tagFilter').value;
    const galleryFilter = document.getElementById('galleryFilter').value;
    const dayNightFilter = document.getElementById('dayNightFilter').value;
    
    // Map tag filter value to animalType
    const tagToType = {
        'Buck': 'buck', 'Doe': 'doe', 'Turkey': 'turkey', 'Bear': 'bear',
        'Predator': 'predator', 'Bird': 'bird', 'Human': 'human',
        'Vehicle/ATV': 'vehicle', 'Other': 'other_tagged', 'No Animals': 'no_animals'
    };
    const filterType = tagFilter && tagFilter !== 'untagged' ? tagToType[tagFilter] : null;
    
    // Build filtered arrays for each tag type
    const filteredArrays = {};
    
    // 30 minutes in milliseconds
    const thirtyMinMs = 30 * 60 * 1000;
    
    dashboardPhotos.forEach(photo => {
        if (cameraFilter && photo.camera !== cameraFilter) return;
        if (locationFilter && photo.location !== locationFilter) return;
        if (galleryFilter && (!photo.photoGroupIds || !photo.photoGroupIds.includes(galleryFilter))) return;
        if (filterType && photo.animalType !== filterType) return;
        
        // Day/Night filter
        if (dayNightFilter) {
            const sun = sunData[photo.dateStr];
            if (sun && sun.sunrise !== undefined && sun.sunset !== undefined) {
                const dayStart = sun.sunrise - thirtyMinMs; // 30 min before sunrise
                const dayEnd = sun.sunset + thirtyMinMs;    // 30 min after sunset
                const isDaytime = photo.timeMs >= dayStart && photo.timeMs <= dayEnd;
                
                if (dayNightFilter === 'day' && !isDaytime) return;
                if (dayNightFilter === 'night' && isDaytime) return;
            }
        }
        
        // Debug: log first photo to check photoUrl
        if (Object.keys(filteredArrays).length === 0) {
            console.log('applyDashboardFilters - first photo:', photo);
        }
        
        const point = {
            x: photo.dateMs,
            y: photo.timeMs,
            camera: photo.camera,
            location: photo.location,
            label: photo.name,
            photoId: photo.photoId,
            photoUrl: photo.photoUrl,
            windSpeed: photo.windSpeed,
            windDirection: photo.windDirection
        };
        
        if (!filteredArrays[photo.animalType]) {
            filteredArrays[photo.animalType] = [];
        }
        filteredArrays[photo.animalType].push(point);
    });
    
    // Update chart series by name
    const chart = Highcharts.charts.find(c => c && c.renderTo && c.renderTo.id === 'chart_main');
    if (chart) {
        Object.keys(tagConfig).forEach(tagType => {
            const config = tagConfig[tagType];
            const series = chart.series.find(s => s.name === config.name);
            if (series) {
                const dataToSet = filteredArrays[tagType] || [];
                // Debug: log what we're setting
                if (dataToSet.length > 0 && tagType === 'doe') {
                    console.log('Setting doe series data, first point:', dataToSet[0]);
                }
                series.setData(dataToSet, false);
                // Debug: check what's in the series after setData
                if (series.data.length > 0 && tagType === 'doe') {
                    console.log('After setData, first series point:', series.data[0]);
                    console.log('After setData, first point options:', series.data[0].options);
                }
            }
        });
        chart.redraw();
    }
    
    // Update polar chart with filtered doe/buck data
    updatePolarChartFiltered(filteredArrays['doe'] || [], filteredArrays['buck'] || []);
    
    // Update weather chart with filtered data
    updateWeatherChart();
}

async function initializeDashboard() {
    console.log('initializeDashboard called');
    showLoading('Building dashboard...');
    dashboardInitialized = true;
    
    // Process photos for chart
    await processPhotosForChart();
    
    createMainChart();
    createPolarChart();
    createWeatherChart();
    loadForecast();
    
    hideLoading();
}

function convertToEST(photoDateUtc) {
    if (!photoDateUtc || !photoDateUtc.includes('T')) return null;
    const [datePart, timePart] = photoDateUtc.replace('Z', '').split('T');
    const fullDateTime = new Date(datePart + 'T' + timePart + 'Z');
    const estDateTime = new Date(fullDateTime.getTime() + (CONFIG.timezoneOffset * 60 * 60 * 1000));
    
    const year = estDateTime.getUTCFullYear();
    const month = String(estDateTime.getUTCMonth() + 1).padStart(2, '0');
    const day = String(estDateTime.getUTCDate()).padStart(2, '0');
    const dateStr = `${year}-${month}-${day}`;
    
    const hours = estDateTime.getUTCHours();
    const minutes = estDateTime.getUTCMinutes();
    const seconds = estDateTime.getUTCSeconds();
    const timeMs = ((hours * 3600) + (minutes * 60) + seconds) * 1000;
    const dateMs = new Date(dateStr + 'T00:00:00').getTime();
    
    return { dateStr, timeMs, dateMs };
}

function timeToMs(timeStr) {
    if (!timeStr) return -1;
    const parts = timeStr.split(':');
    if (parts.length < 2) return -1;
    return ((parseInt(parts[0]) * 3600) + (parseInt(parts[1]) * 60) + (parts[2] ? parseInt(parts[2]) : 0)) * 1000;
}

function calculateMoonPhase(dateStr) {
    const knownNewMoon = new Date(2000, 0, 6);
    const targetDate = new Date(dateStr);
    const lunarCycle = 29.53059;
    let phase = ((targetDate - knownNewMoon) / (1000 * 60 * 60 * 24) % lunarCycle) / lunarCycle;
    return phase < 0 ? phase + 1 : phase;
}

// Calculate moon illumination percentage from phase
function getMoonIllumination(phase) {
    // Convert phase (0-1) to illumination (0-100%)
    // 0 = new moon (0%), 0.5 = full moon (100%)
    const illum = (1 - Math.cos(phase * 2 * Math.PI)) / 2 * 100;
    return Math.round(illum);
}

function getMoonPhaseName(phase) {
    if (phase < 0.0625) return 'New Moon';
    if (phase < 0.1875) return 'Waxing Crescent';
    if (phase < 0.3125) return 'First Quarter';
    if (phase < 0.4375) return 'Waxing Gibbous';
    if (phase < 0.5625) return 'Full Moon';
    if (phase < 0.6875) return 'Waning Gibbous';
    if (phase < 0.8125) return 'Last Quarter';
    if (phase < 0.9375) return 'Waning Crescent';
    return 'New Moon';
}

function getMoonSymbol(phase) {
    if (phase < 0.0625) return '';
    if (phase < 0.1875) return '';
    if (phase < 0.3125) return '';
    if (phase < 0.4375) return '';
    if (phase < 0.5625) return '';
    if (phase < 0.6875) return '';
    if (phase < 0.8125) return '';
    if (phase < 0.9375) return '';
    return '';
}

// Calculate moonrise and moonset times astronomically
function calculateMoonTimes(dateStr, lat, lng) {
    const RAD = Math.PI / 180;
    const DEG = 180 / Math.PI;
    
    // Parse date
    const date = new Date(dateStr + 'T00:00:00');
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    
    // Julian Day Number
    const a = Math.floor((14 - month) / 12);
    const y = year + 4800 - a;
    const m = month + 12 * a - 3;
    const JD = day + Math.floor((153 * m + 2) / 5) + 365 * y + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400) - 32045;
    
    // Days since J2000.0
    const d = JD - 2451545.0;
    
    // Moon's orbital elements
    const N = (125.1228 - 0.0529538083 * d) % 360; // Long. of ascending node
    const i = 5.1454; // Inclination
    const w = (318.0634 + 0.1643573223 * d) % 360; // Arg. of perigee
    const a_moon = 60.2666; // Mean distance (Earth radii)
    const e = 0.054900; // Eccentricity
    const M = (115.3654 + 13.0649929509 * d) % 360; // Mean anomaly
    
    // Sun's position (needed for perturbations)
    const Ms = (356.0470 + 0.9856002585 * d) % 360; // Sun mean anomaly
    const Ls = (280.4665 + 0.9856474 * d) % 360; // Sun mean longitude
    const Lm = (218.3165 + 13.1763966 * d) % 360; // Moon mean longitude
    const D = Lm - Ls; // Moon's mean elongation
    const F = Lm - N; // Moon's argument of latitude
    
    // Eccentric anomaly (iterative)
    let E = M + (e * DEG) * Math.sin(M * RAD) * (1 + e * Math.cos(M * RAD));
    for (let j = 0; j < 3; j++) {
        E = E - (E - (e * DEG) * Math.sin(E * RAD) - M) / (1 - e * Math.cos(E * RAD));
    }
    
    // Moon's position in orbital plane
    const xv = a_moon * (Math.cos(E * RAD) - e);
    const yv = a_moon * Math.sqrt(1 - e * e) * Math.sin(E * RAD);
    const v = Math.atan2(yv, xv) * DEG; // True anomaly
    const r = Math.sqrt(xv * xv + yv * yv); // Distance
    
    // Moon's position in ecliptic coordinates
    let xeclip = r * (Math.cos(N * RAD) * Math.cos((v + w) * RAD) - Math.sin(N * RAD) * Math.sin((v + w) * RAD) * Math.cos(i * RAD));
    let yeclip = r * (Math.sin(N * RAD) * Math.cos((v + w) * RAD) + Math.cos(N * RAD) * Math.sin((v + w) * RAD) * Math.cos(i * RAD));
    let zeclip = r * Math.sin((v + w) * RAD) * Math.sin(i * RAD);
    
    // Apply perturbations
    const lonecl = Math.atan2(yeclip, xeclip) * DEG;
    const latecl = Math.atan2(zeclip, Math.sqrt(xeclip * xeclip + yeclip * yeclip)) * DEG;
    
    // Perturbation corrections
    let dlon = -1.274 * Math.sin((M - 2 * D) * RAD) // Evection
             + 0.658 * Math.sin(2 * D * RAD) // Variation
             - 0.186 * Math.sin(Ms * RAD) // Yearly equation
             - 0.059 * Math.sin((2 * M - 2 * D) * RAD)
             - 0.057 * Math.sin((M - 2 * D + Ms) * RAD)
             + 0.053 * Math.sin((M + 2 * D) * RAD)
             + 0.046 * Math.sin((2 * D - Ms) * RAD)
             + 0.041 * Math.sin((M - Ms) * RAD)
             - 0.035 * Math.sin(D * RAD) // Parallactic equation
             - 0.031 * Math.sin((M + Ms) * RAD)
             - 0.015 * Math.sin((2 * F - 2 * D) * RAD)
             + 0.011 * Math.sin((M - 4 * D) * RAD);
    
    let dlat = -0.173 * Math.sin((F - 2 * D) * RAD)
             - 0.055 * Math.sin((M - F - 2 * D) * RAD)
             - 0.046 * Math.sin((M + F - 2 * D) * RAD)
             + 0.033 * Math.sin((F + 2 * D) * RAD)
             + 0.017 * Math.sin((2 * M + F) * RAD);
    
    const moonLon = lonecl + dlon;
    const moonLat = latecl + dlat;
    
    // Convert to equatorial coordinates
    const obliq = 23.4393 - 0.0000004 * d; // Obliquity of ecliptic
    
    const xe = Math.cos(moonLon * RAD) * Math.cos(moonLat * RAD);
    const ye = Math.cos(obliq * RAD) * Math.sin(moonLon * RAD) * Math.cos(moonLat * RAD) - Math.sin(obliq * RAD) * Math.sin(moonLat * RAD);
    const ze = Math.sin(obliq * RAD) * Math.sin(moonLon * RAD) * Math.cos(moonLat * RAD) + Math.cos(obliq * RAD) * Math.sin(moonLat * RAD);
    
    const RA = Math.atan2(ye, xe) * DEG; // Right Ascension
    const Dec = Math.asin(ze) * DEG; // Declination
    
    // Calculate rise/set times
    // Moon's apparent angular radius is ~0.26, refraction ~0.57
    const h0 = 0.125; // Moon's altitude at rise/set (degrees)
    
    // Sidereal time at midnight
    const GMST0 = (Ls + 180) % 360;
    
    // Hour angle at rise/set
    const cosH = (Math.sin(h0 * RAD) - Math.sin(lat * RAD) * Math.sin(Dec * RAD)) / (Math.cos(lat * RAD) * Math.cos(Dec * RAD));
    
    let moonrise = null;
    let moonset = null;
    
    if (cosH >= -1 && cosH <= 1) {
        const H = Math.acos(cosH) * DEG;
        
        // Local sidereal time at rise/set
        const LSTrise = (RA - H + 360) % 360;
        const LSTset = (RA + H + 360) % 360;
        
        // Convert LST to UT
        let UTrise = (LSTrise - GMST0 - lng + 360) % 360 / 15;
        let UTset = (LSTset - GMST0 - lng + 360) % 360 / 15;
        
        // Normalize to 0-24
        while (UTrise < 0) UTrise += 24;
        while (UTrise >= 24) UTrise -= 24;
        while (UTset < 0) UTset += 24;
        while (UTset >= 24) UTset -= 24;
        
        // Apply correction for moon's motion (~50 min delay per day)
        // Moon moves ~13 per day, so rise/set shifts ~50 min later
        UTrise += UTrise * 0.0347;
        UTset += UTset * 0.0347;
        
        // Normalize again
        while (UTrise >= 24) UTrise -= 24;
        while (UTset >= 24) UTset -= 24;
        
        // DST detection for US
        function isDST(y, m, d) {
            if (m === 3) {
                const firstDay = new Date(y, 2, 1).getDay();
                const secondSunday = 8 + (7 - firstDay) % 7;
                return d >= secondSunday;
            }
            if (m === 11) {
                const firstDay = new Date(y, 10, 1).getDay();
                const firstSunday = 1 + (7 - firstDay) % 7;
                return d < firstSunday;
            }
            return m >= 4 && m <= 10;
        }
        
        const tzOffset = isDST(year, month, day) ? -4 : -5;
        
        let localRise = UTrise + tzOffset;
        let localSet = UTset + tzOffset;
        
        while (localRise < 0) localRise += 24;
        while (localRise >= 24) localRise -= 24;
        while (localSet < 0) localSet += 24;
        while (localSet >= 24) localSet -= 24;
        
        moonrise = Math.round(localRise * 3600 * 1000);
        moonset = Math.round(localSet * 3600 * 1000);
    }
    
    // Calculate moon phase and illumination
    const phase = calculateMoonPhase(dateStr);
    const illumination = getMoonIllumination(phase);
    
    // Calculate moon's maximum altitude (apex) for this date
    // Apex altitude = 90 - |latitude - declination|
    const apexAltitude = Math.min(90, 90 - Math.abs(lat - Dec));
    
    return {
        moonrise: moonrise,
        moonset: moonset,
        phase: phase,
        illumination: illumination,
        phaseName: getMoonPhaseName(phase),
        symbol: getMoonSymbol(phase),
        apexAltitude: Math.max(0, apexAltitude)
    };
}

// Calculate sunrise/sunset times astronomically (no API needed)
function calculateSunTimes(dateStr, lat, lng) {
    const date = new Date(dateStr + 'T12:00:00');
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    
    // Day of year
    const N1 = Math.floor(275 * month / 9);
    const N2 = Math.floor((month + 9) / 12);
    const N3 = (1 + Math.floor((year - 4 * Math.floor(year / 4) + 2) / 3));
    const N = N1 - (N2 * N3) + day - 30;
    
    // Convert longitude to hour value
    const lngHour = lng / 15;
    
    // Sunrise calculation
    const tRise = N + ((6 - lngHour) / 24);
    const tSet = N + ((18 - lngHour) / 24);
    
    // Sun's mean anomaly
    const MRise = (0.9856 * tRise) - 3.289;
    const MSet = (0.9856 * tSet) - 3.289;
    
    // Sun's true longitude
    function calcTrueLong(M) {
        let L = M + (1.916 * Math.sin(M * Math.PI / 180)) + (0.020 * Math.sin(2 * M * Math.PI / 180)) + 282.634;
        while (L < 0) L += 360;
        while (L >= 360) L -= 360;
        return L;
    }
    
    const LRise = calcTrueLong(MRise);
    const LSet = calcTrueLong(MSet);
    
    // Sun's right ascension
    function calcRA(L) {
        let RA = Math.atan(0.91764 * Math.tan(L * Math.PI / 180)) * 180 / Math.PI;
        const Lquadrant = Math.floor(L / 90) * 90;
        const RAquadrant = Math.floor(RA / 90) * 90;
        RA = RA + (Lquadrant - RAquadrant);
        return RA / 15; // Convert to hours
    }
    
    const RARise = calcRA(LRise);
    const RASet = calcRA(LSet);
    
    // Sun's declination
    function calcDec(L) {
        const sinDec = 0.39782 * Math.sin(L * Math.PI / 180);
        return Math.asin(sinDec) * 180 / Math.PI;
    }
    
    const decRise = calcDec(LRise);
    const decSet = calcDec(LSet);
    
    // Sun's local hour angle
    const zenith = 90.833; // Official sunrise/sunset (accounts for refraction)
    
    function calcHourAngle(dec, forRise) {
        const latRad = lat * Math.PI / 180;
        const decRad = dec * Math.PI / 180;
        const cosH = (Math.cos(zenith * Math.PI / 180) - (Math.sin(latRad) * Math.sin(decRad))) / (Math.cos(latRad) * Math.cos(decRad));
        
        if (cosH > 1) return null; // Sun never rises
        if (cosH < -1) return null; // Sun never sets
        
        let H = Math.acos(cosH) * 180 / Math.PI;
        if (forRise) H = 360 - H;
        return H / 15; // Convert to hours
    }
    
    const HRise = calcHourAngle(decRise, true);
    const HSet = calcHourAngle(decSet, false);
    
    if (HRise === null || HSet === null) {
        // Polar day/night - use defaults
        return { sunrise: 6 * 3600 * 1000, sunset: 18 * 3600 * 1000 };
    }
    
    // Local mean time of rise/set
    const TRise = HRise + RARise - (0.06571 * tRise) - 6.622;
    const TSet = HSet + RASet - (0.06571 * tSet) - 6.622;
    
    // Adjust to UTC
    let UTRise = TRise - lngHour;
    let UTSet = TSet - lngHour;
    
    // Normalize to 0-24
    while (UTRise < 0) UTRise += 24;
    while (UTRise >= 24) UTRise -= 24;
    while (UTSet < 0) UTSet += 24;
    while (UTSet >= 24) UTSet -= 24;
    
    // Determine if DST is in effect (US rules: 2nd Sunday March - 1st Sunday November)
    function isDST(y, m, d) {
        // March: DST starts 2nd Sunday
        if (m === 3) {
            const firstDay = new Date(y, 2, 1).getDay();
            const secondSunday = 8 + (7 - firstDay) % 7;
            return d >= secondSunday;
        }
        // November: DST ends 1st Sunday
        if (m === 11) {
            const firstDay = new Date(y, 10, 1).getDay();
            const firstSunday = 1 + (7 - firstDay) % 7;
            return d < firstSunday;
        }
        // April-October: DST
        return m >= 4 && m <= 10;
    }
    
    // Eastern Time: UTC-5 (EST) or UTC-4 (EDT)
    const tzOffset = isDST(year, month, day) ? -4 : -5;
    
    // Convert to local time
    let localRise = UTRise + tzOffset;
    let localSet = UTSet + tzOffset;
    
    // Normalize
    while (localRise < 0) localRise += 24;
    while (localRise >= 24) localRise -= 24;
    while (localSet < 0) localSet += 24;
    while (localSet >= 24) localSet -= 24;
    
    // Convert to milliseconds from midnight
    const sunriseMs = Math.round(localRise * 3600 * 1000);
    const sunsetMs = Math.round(localSet * 3600 * 1000);
    
    return { sunrise: sunriseMs, sunset: sunsetMs };
}

async function updateLocationFromPhotos() {
    // Find first photo with gpsLocation
    const photoWithGps = allPhotos.find(p => p.gpsLocation && p.gpsLocation.lat && p.gpsLocation.lon);
    
    if (!photoWithGps) {
        console.log('No GPS data found in photos, using default location');
        return;
    }
    
    // Update CONFIG with GPS coordinates
    CONFIG.fixedLat = photoWithGps.gpsLocation.lat;
    CONFIG.fixedLng = photoWithGps.gpsLocation.lon;
    
    console.log(`GPS location from photos: ${CONFIG.fixedLat}, ${CONFIG.fixedLng}`);
    
    // Reverse geocode to get city/town name
    try {
        const response = await fetch(
            `https://nominatim.openstreetmap.org/reverse?format=json&lat=${CONFIG.fixedLat}&lon=${CONFIG.fixedLng}&zoom=14`,
            { headers: { 'User-Agent': 'TrailCamHQ/1.0' } }
        );
        
        if (response.ok) {
            const data = await response.json();
            const address = data.address || {};
            console.log('Reverse geocode address:', address);
            
            // Try to get city/town/village name
            const city = address.city || address.town || address.village || address.municipality || '';
            const state = address.state || '';
            
            if (city) {
                // Format as "City, ST" (abbreviate state if possible)
                const stateAbbr = getStateAbbreviation(state) || state;
                CONFIG.fixedLocationName = stateAbbr ? `${city}, ${stateAbbr}` : city;
                console.log(`Location name: ${CONFIG.fixedLocationName}`);
            }
        }
    } catch (e) {
        console.log('Reverse geocoding failed, using default location name');
    }
}

function getStateAbbreviation(stateName) {
    const states = {
        'Alabama': 'AL', 'Alaska': 'AK', 'Arizona': 'AZ', 'Arkansas': 'AR', 'California': 'CA',
        'Colorado': 'CO', 'Connecticut': 'CT', 'Delaware': 'DE', 'Florida': 'FL', 'Georgia': 'GA',
        'Hawaii': 'HI', 'Idaho': 'ID', 'Illinois': 'IL', 'Indiana': 'IN', 'Iowa': 'IA',
        'Kansas': 'KS', 'Kentucky': 'KY', 'Louisiana': 'LA', 'Maine': 'ME', 'Maryland': 'MD',
        'Massachusetts': 'MA', 'Michigan': 'MI', 'Minnesota': 'MN', 'Mississippi': 'MS', 'Missouri': 'MO',
        'Montana': 'MT', 'Nebraska': 'NE', 'Nevada': 'NV', 'New Hampshire': 'NH', 'New Jersey': 'NJ',
        'New Mexico': 'NM', 'New York': 'NY', 'North Carolina': 'NC', 'North Dakota': 'ND', 'Ohio': 'OH',
        'Oklahoma': 'OK', 'Oregon': 'OR', 'Pennsylvania': 'PA', 'Rhode Island': 'RI', 'South Carolina': 'SC',
        'South Dakota': 'SD', 'Tennessee': 'TN', 'Texas': 'TX', 'Utah': 'UT', 'Vermont': 'VT',
        'Virginia': 'VA', 'Washington': 'WA', 'West Virginia': 'WV', 'Wisconsin': 'WI', 'Wyoming': 'WY'
    };
    return states[stateName] || null;
}

async function prefetchSunData() {
    // Collect unique dates from photos
    const uniqueDates = new Set();
    for (const photo of allPhotos) {
        if (!photo.photoDateUtc || !photo.photoDateUtc.includes('T')) continue;
        const converted = convertToEST(photo.photoDateUtc);
        if (converted) {
            uniqueDates.add(converted.dateStr);
        }
    }
    
    // Check which dates need calculation (missing or incomplete data)
    const datesToCalc = Array.from(uniqueDates).filter(d => {
        const existing = sunData[d];
        // Recalculate if missing or missing moon data
        return !existing || existing.moonrise === undefined;
    });
    
    if (datesToCalc.length === 0) {
        console.log('All sun/moon data already calculated');
        return;
    }
    
    console.log(`Calculating sun/moon data for ${datesToCalc.length} dates...`);
    
    const newSunData = {};
    for (const dateStr of datesToCalc) {
        // Clear existing incomplete data
        delete sunData[dateStr];
        // Calculate fresh data
        getSunData(dateStr);
        newSunData[dateStr] = sunData[dateStr];
    }
    
    console.log('Calculated sun/moon data for', datesToCalc.length, 'dates');
    
    // Sync to cache (includes all sun and moon data now)
    if (Object.keys(newSunData).length > 0) {
        await syncSunDataToCache(newSunData);
    }
}

async function processPhotosForPrediction() {
    // Build dashboardPhotos array for prediction calculations
    dashboardPhotos = [];
    
    for (const photo of allPhotos) {
        const converted = convertToEST(photo.photoDateUtc);
        if (!converted) continue;
        
        const tagNames = (photo.tagIds || []).map(id => tagIdToName[id]).filter(n => n);
        let animalType = 'other';
        
        // Check if photo has no tags at all
        if (!photo.tagIds || photo.tagIds.length === 0) {
            animalType = 'untagged';
        } else if (tagNames.includes('Buck')) animalType = 'buck';
        else if (tagNames.includes('Doe')) animalType = 'doe';
        else if (tagNames.includes('Turkey')) animalType = 'turkey';
        else if (tagNames.includes('Bear')) animalType = 'bear';
        else if (tagNames.includes('Predator')) animalType = 'predator';
        else if (tagNames.includes('Bird')) animalType = 'bird';
        else if (tagNames.includes('Human')) animalType = 'human';
        else if (tagNames.includes('Vehicle/ATV')) animalType = 'vehicle';
        else if (tagNames.includes('Other')) animalType = 'other_tagged';
        else if (tagNames.includes('No Animals')) animalType = 'no_animals';
        
        if (animalType === 'other') continue;
        
        const processedPhoto = {
            ...converted,
            photoId: photo.photoId,
            photoUrl: photo.photoUrl,
            camera: photo.cameraName,
            location: photo.cameraLocation || '',
            photoGroupIds: photo.photoGroupIds || [],
            name: (photo.photoGroupIds || []).map(id => groupsLookup[id]).filter(n => n).join(', '),
            animalType,
            windSpeed: photo.weatherRecord?.windDirection?.speed ?? '',
            windDirection: photo.weatherRecord?.windDirection?.degrees ?? '',
            tempMin: photo.weatherRecord?.temperatureRange12Hours?.min ?? '',
            tempMax: photo.weatherRecord?.temperatureRange12Hours?.max ?? '',
            barometricPressure: photo.weatherRecord?.barometricPressure ?? ''
        };
        
        dashboardPhotos.push(processedPhoto);
    }
    
    console.log('Processed', dashboardPhotos.length, 'photos for prediction');
}

async function prefetchForecast() {
    try {
        const lat = CONFIG.fixedLat;
        const lng = CONFIG.fixedLng;
        
        const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&daily=temperature_2m_max,temperature_2m_min,precipitation_probability_max,wind_speed_10m_max,wind_direction_10m_dominant&hourly=surface_pressure&current=temperature_2m,relative_humidity_2m,wind_speed_10m,wind_direction_10m,wind_gusts_10m,surface_pressure,precipitation&temperature_unit=fahrenheit&wind_speed_unit=mph&timezone=America%2FNew_York&forecast_days=10`;
        
        const response = await fetch(url);
        
        if (response.ok) {
            cachedForecastData = await response.json();
            console.log('Pre-fetched forecast data');
            
            // Process forecast days for prediction chart
            if (cachedForecastData.daily && cachedForecastData.daily.time) {
                const dailyPressure = [];
                if (cachedForecastData.hourly && cachedForecastData.hourly.surface_pressure) {
                    for (let d = 0; d < cachedForecastData.daily.time.length; d++) {
                        const dayStart = d * 24;
                        const dayPressures = cachedForecastData.hourly.surface_pressure.slice(dayStart, dayStart + 24);
                        const avgPressure = dayPressures.reduce((a, b) => a + b, 0) / dayPressures.length;
                        dailyPressure.push((avgPressure / 33.864).toFixed(2));
                    }
                }
                
                forecastDays = cachedForecastData.daily.time.map((date, i) => ({
                    datetime: date,
                    tempmax: cachedForecastData.daily.temperature_2m_max[i],
                    tempmin: cachedForecastData.daily.temperature_2m_min[i],
                    windspeed: cachedForecastData.daily.wind_speed_10m_max[i],
                    winddir: cachedForecastData.daily.wind_direction_10m_dominant[i],
                    precipprob: cachedForecastData.daily.precipitation_probability_max[i],
                    pressure: dailyPressure[i] || null,
                    moonphase: calculateMoonPhase(date)
                }));
                
                // Prediction chart will be created when Dashboard tab is opened
            }
        }
    } catch (error) {
        console.error('Error pre-fetching forecast:', error);
    }
}

function getWindDirection(degrees) {
    if (degrees === '' || degrees === null || degrees === undefined) return '';
    const dirs = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
    return dirs[Math.round(degrees / 22.5) % 16];
}

// Calculate how much moonlight is available during nighttime hours
// Returns: { moonHours: hours moon is up at night, effectiveMoonlight: moon-hours weighted by illumination, nightMoonPercent: % of night with moon }
function calculateNighttimeMoonlight(sunset, sunrise, moonrise, moonset, illumination) {
    const DAY_MS = 24 * 60 * 60 * 1000;
    
    // Handle null moonrise/moonset (polar regions or calculation edge cases)
    if (moonrise === null || moonset === null) {
        return { moonHours: 0, effectiveMoonlight: 0, nightMoonPercent: 0 };
    }
    
    // Night spans from sunset to next sunrise
    // If sunrise < sunset, sunrise is next day
    let nightStart = sunset;
    let nightEnd = sunrise < sunset ? sunrise + DAY_MS : sunrise;
    let nightDuration = nightEnd - nightStart;
    
    // Build list of moon-up periods during the night
    // Moon could rise before or after sunset, and set before or after sunrise
    let moonUpDuring = 0;
    
    // Normalize times - consider moon might rise/set multiple "windows"
    // Simple approach: calculate overlap between [nightStart, nightEnd] and moon-up period
    
    // Moon up period for this day
    let moonStart = moonrise;
    let moonEnd = moonset;
    
    // If moonset < moonrise, moon sets next day
    if (moonEnd < moonStart) {
        moonEnd += DAY_MS;
    }
    
    // Check overlap with night period
    // Night: [nightStart, nightEnd]
    // Moon: [moonStart, moonEnd]
    
    // Also check moon from previous day (moonStart - DAY_MS to moonEnd - DAY_MS)
    const periods = [
        { start: moonStart - DAY_MS, end: moonEnd - DAY_MS },
        { start: moonStart, end: moonEnd },
        { start: moonStart + DAY_MS, end: moonEnd + DAY_MS }
    ];
    
    for (const period of periods) {
        const overlapStart = Math.max(nightStart, period.start);
        const overlapEnd = Math.min(nightEnd, period.end);
        if (overlapEnd > overlapStart) {
            moonUpDuring += (overlapEnd - overlapStart);
        }
    }
    
    // Convert to hours
    const moonHours = moonUpDuring / (60 * 60 * 1000);
    const nightHours = nightDuration / (60 * 60 * 1000);
    
    // Effective moonlight = moon hours * illumination fraction
    const effectiveMoonlight = moonHours * (illumination / 100);
    
    // Percentage of night with moon up
    const nightMoonPercent = nightHours > 0 ? Math.round((moonHours / nightHours) * 100) : 0;
    
    return {
        moonHours: Math.round(moonHours * 10) / 10,
        effectiveMoonlight: Math.round(effectiveMoonlight * 10) / 10,
        nightMoonPercent: nightMoonPercent,
        nightHours: Math.round(nightHours * 10) / 10
    };
}

// Calculate moon altitude at a given time (ms from midnight)
// Returns altitude in degrees (0 when below horizon)
function getMoonAltitudeAtTime(timeMs, moonrise, moonset, apexAltitude) {
    if (moonrise === null || moonset === null) return 0;
    
    const DAY_MS = 24 * 60 * 60 * 1000;
    let rise = moonrise;
    let set = moonset;
    let t = timeMs;
    
    // Calculate apex time (midpoint between rise and set)
    let apexTime;
    if (set < rise) {
        // Moon sets next day
        set += DAY_MS;
        apexTime = (rise + set) / 2;
    } else {
        apexTime = (rise + set) / 2;
    }
    
    // Normalize time to check if moon is up
    // Try current time, and time + 24h for overnight cases
    const timesToCheck = [t, t + DAY_MS];
    
    for (const checkTime of timesToCheck) {
        if (checkTime >= rise && checkTime <= set) {
            // Moon is up - calculate altitude using sinusoidal model
            const progress = (checkTime - rise) / (set - rise);
            const altitude = apexAltitude * Math.sin(progress * Math.PI);
            return Math.max(0, altitude);
        }
    }
    
    return 0; // Moon is below horizon
}

// Calculate moonlight intensity for each of the 12 night segments (instantaneous method)
// Returns array of 12 values (0-100) representing moonlight intensity at each segment midpoint
// 100 = theoretical maximum (full moon at max possible altitude for this latitude)
function calculateSegmentMoonlight(sunrise, sunset, moonrise, moonset, moonIllumination, apexAltitude) {
    const MAX_ALTITUDE = 83; // Maximum possible moon altitude at this latitude
    const DAY_MS = 24 * 60 * 60 * 1000;
    
    // Calculate night duration and segment length
    let nightStart = sunset;
    let nightEnd = sunrise < sunset ? sunrise + DAY_MS : sunrise;
    let nightDuration = nightEnd - nightStart;
    let segmentLength = nightDuration / 12;
    
    const segmentMoonlight = [];
    
    for (let i = 0; i < 12; i++) {
        // Calculate midpoint of this segment
        let midpoint = nightStart + (i + 0.5) * segmentLength;
        if (midpoint >= DAY_MS) midpoint -= DAY_MS;
        
        // Get moon altitude at midpoint
        const altitude = getMoonAltitudeAtTime(midpoint, moonrise, moonset, apexAltitude);
        
        // Calculate normalized moonlight intensity
        // moonlight = (illumination / 100) * (sin(altitude) / sin(maxAltitude)) * 100
        let moonlight = 0;
        if (altitude > 0) {
            const altFactor = Math.sin(altitude * Math.PI / 180) / Math.sin(MAX_ALTITUDE * Math.PI / 180);
            moonlight = (moonIllumination / 100) * altFactor * 100;
        }
        
        segmentMoonlight.push(Math.round(moonlight * 10) / 10);
    }
    
    return segmentMoonlight;
}

function getSunData(dateStr) {
    if (sunData[dateStr]) return sunData[dateStr];
    
    // Calculate sunrise/sunset astronomically (no API needed)
    const sunTimes = calculateSunTimes(dateStr, CONFIG.fixedLat, CONFIG.fixedLng);
    
    // Calculate moon data (moonrise, moonset, phase, illumination)
    const moonTimes = calculateMoonTimes(dateStr, CONFIG.fixedLat, CONFIG.fixedLng);
    
    // Calculate nighttime moonlight totals
    const moonlight = calculateNighttimeMoonlight(
        sunTimes.sunset,
        sunTimes.sunrise,
        moonTimes.moonrise,
        moonTimes.moonset,
        moonTimes.illumination
    );
    
    // Calculate segment moonlight (12 values for each night segment)
    const segmentMoonlight = calculateSegmentMoonlight(
        sunTimes.sunrise,
        sunTimes.sunset,
        moonTimes.moonrise,
        moonTimes.moonset,
        moonTimes.illumination,
        moonTimes.apexAltitude || 60 // Default apex if not calculated
    );
    
    sunData[dateStr] = {
        sunrise: sunTimes.sunrise,
        sunset: sunTimes.sunset,
        moonrise: moonTimes.moonrise,
        moonset: moonTimes.moonset,
        moonphase: moonTimes.phase,
        moonIllumination: moonTimes.illumination,
        moonPhaseName: moonTimes.phaseName,
        moonSymbol: moonTimes.symbol,
        moonApexAltitude: moonTimes.apexAltitude,
        // Nighttime moonlight totals
        nightMoonHours: moonlight.moonHours,
        nightEffectiveMoonlight: moonlight.effectiveMoonlight,
        nightMoonPercent: moonlight.nightMoonPercent,
        nightHours: moonlight.nightHours,
        // Segment moonlight (12 values, 0-100)
        segmentMoonlight: segmentMoonlight
    };
    
    return sunData[dateStr];
}

async function processPhotosForChart() {
    sunriseArray = []; sunsetArray = []; moonArray = [];
    tagArrays = {};
    dashboardPhotos = [];
    
    const uniqueDates = new Set();
    
    // First pass - collect dates and convert photos
    for (const photo of allPhotos) {
        const converted = convertToEST(photo.photoDateUtc);
        if (!converted) continue;
        
        const tagNames = (photo.tagIds || []).map(id => tagIdToName[id]).filter(n => n);
        let animalType = 'other';
        
        // Check if photo has no tags at all
        if (!photo.tagIds || photo.tagIds.length === 0) {
            animalType = 'untagged';
        } else if (tagNames.includes('Buck')) animalType = 'buck';
        else if (tagNames.includes('Doe')) animalType = 'doe';
        else if (tagNames.includes('Turkey')) animalType = 'turkey';
        else if (tagNames.includes('Bear')) animalType = 'bear';
        else if (tagNames.includes('Predator')) animalType = 'predator';
        else if (tagNames.includes('Bird')) animalType = 'bird';
        else if (tagNames.includes('Human')) animalType = 'human';
        else if (tagNames.includes('Vehicle/ATV')) animalType = 'vehicle';
        else if (tagNames.includes('Other')) animalType = 'other_tagged';
        else if (tagNames.includes('No Animals')) animalType = 'no_animals';
        
        if (animalType === 'other') continue; // Skip unknown tag types
        
        uniqueDates.add(converted.dateStr);
        
        const processedPhoto = {
            ...converted,
            photoId: photo.photoId,
            photoUrl: photo.photoUrl,
            camera: photo.cameraName,
            location: photo.cameraLocation || '',
            photoGroupIds: photo.photoGroupIds || [],
            name: (photo.photoGroupIds || []).map(id => groupsLookup[id]).filter(n => n).join(', '),
            animalType,
            windSpeed: photo.weatherRecord?.windDirection?.speed ?? '',
            windDirection: photo.weatherRecord?.windDirection?.degrees ?? '',
            tempMin: photo.weatherRecord?.temperatureRange12Hours?.min ?? '',
            tempMax: photo.weatherRecord?.temperatureRange12Hours?.max ?? '',
            barometricPressure: photo.weatherRecord?.barometricPressure ?? ''
        };
        
        dashboardPhotos.push(processedPhoto);
    }
    
    // Calculate sun data for any missing dates (instant, no API needed)
    const datesToCalc = Array.from(uniqueDates).filter(d => !sunData[d]);
    if (datesToCalc.length > 0) {
        console.log(`Calculating ${datesToCalc.length} missing sun dates...`);
        for (const dateStr of datesToCalc) {
            getSunData(dateStr); // Synchronous calculation
        }
    }
    
    // Build chart arrays - only for tags that exist
    dashboardPhotos.forEach(photo => {
        const point = {
            x: photo.dateMs,
            y: photo.timeMs,
            camera: photo.camera,
            location: photo.location,
            label: photo.name,
            photoId: photo.photoId,
            photoUrl: photo.photoUrl,
            windSpeed: photo.windSpeed,
            windDirection: photo.windDirection
        };
        
        if (!tagArrays[photo.animalType]) {
            tagArrays[photo.animalType] = [];
        }
        tagArrays[photo.animalType].push(point);
    });
    
    // Build sun arrays
    const sortedDates = Array.from(uniqueDates).sort();
    
    sortedDates.forEach(dateStr => {
        const dateMs = new Date(dateStr + 'T12:00:00').getTime();
        const sun = sunData[dateStr];
        if (sun) {
            sunriseArray.push({ x: dateMs, y: sun.sunrise });
            sunsetArray.push({ x: dateMs, y: sun.sunset });
            moonArray.push({ x: dateMs, y: 0.5, moonphase: sun.moonphase, moonlabel: getMoonPhaseName(sun.moonphase), moonsymbol: getMoonSymbol(sun.moonphase) });
        }
    });
    
    // Populate filter dropdowns
    populateDashboardFilters();
}

function createMainChart() {
    const container = document.getElementById('chart_main');
    
    if (!container) {
        console.error('chart_main container not found!');
        return;
    }
    
    // Build dynamic series from tagArrays
    const baseSeries = [{
        type: 'area', name: 'Night (AM)', data: sunriseArray, threshold: 0, color: 'rgba(50, 50, 80, 0.6)', lineWidth: 0, enableMouseTracking: false, showInLegend: false
    }, {
        type: 'area', name: 'Night (PM)', data: sunsetArray, threshold: 24 * 60 * 60 * 1000, color: 'rgba(50, 50, 80, 0.6)', lineWidth: 0, enableMouseTracking: false, showInLegend: false
    }, {
        type: 'scatter', name: 'Moon', data: moonArray, yAxis: 1, marker: { enabled: false },
        dataLabels: { enabled: true, y: -60, formatter: function() { return this.point.moonsymbol; }, style: { fontSize: '16px', textOutline: 'none' } },
        showInLegend: false, enableMouseTracking: false
    }];
    
    // Add series for each tag type that has data
    const tagSeries = Object.keys(tagArrays).map(tagType => {
        const config = tagConfig[tagType] || { color: '#888', symbol: 'circle', radius: 4, name: tagType };
        return {
            type: 'scatter',
            name: config.name,
            data: tagArrays[tagType],
            color: config.color,
            marker: { radius: config.radius, symbol: config.symbol },
            tooltip: { enabled: false }
        };
    });
    
    console.log('Creating chart with', tagSeries.length, 'tag series');
    
    try {
        Highcharts.stockChart('chart_main', {
        chart: {
            backgroundColor: '#2a2a2b',
            style: { fontFamily: "'Segoe UI', sans-serif" },
            marginLeft: 70,
            marginBottom: 40
        },
        accessibility: { enabled: false },
        title: { text: 'Trail Observations', style: { color: '#E0E0E3', fontSize: '20px' } },
        legend: { 
            enabled: true, 
            itemStyle: { color: '#E0E0E3' }, 
            itemHoverStyle: { color: '#FFF' },
            floating: true,
            align: 'left',
            verticalAlign: 'bottom',
            x: 10,
            y: 0
        },
        rangeSelector: {
            selected: 1,
            buttons: [{ type: 'week', count: 1, text: '1w' }, { type: 'month', count: 1, text: '1m' }, { type: 'month', count: 3, text: '3m' }],
            inputEnabled: false,
            floating: false,
            verticalAlign: 'bottom',
            buttonPosition: {
                align: 'right',
                x: -10
            },
            y: 10,
            buttonTheme: { fill: '#3e3e40', stroke: '#606063', style: { color: '#E0E0E3' }, states: { hover: { fill: '#4e4e50' }, select: { fill: '#1C86EE', style: { color: 'white' } } } }
        },
        navigator: { enabled: true, height: 20, margin: 20 },
        xAxis: {
            type: 'datetime',
            gridLineWidth: 1,
            gridLineColor: '#444',
            labels: { style: { color: '#E0E0E3' }, formatter: function() { return Highcharts.dateFormat('%b %e', this.value); } }
        },
        yAxis: [{
            type: 'datetime',
            min: 0,
            max: 24 * 60 * 60 * 1000,
            tickInterval: 3 * 60 * 60 * 1000,
            gridLineColor: '#444',
            opposite: false,
            top: '10%',
            height: '90%',
            labels: { 
                align: 'right',
                x: -10,
                y: 3,
                style: { color: '#E0E0E3' }, 
                formatter: function() { return Highcharts.dateFormat('%l %P', this.value); } 
            },
            title: { enabled: false },
            reversed: false
        }, {
            top: '0%', height: '5%', min: 0, max: 1, gridLineWidth: 0, tickLength: 0, labels: { enabled: false }, title: { enabled: false }, opposite: false
        }],
        tooltip: {
            enabled: false  // Disable floating tooltip, we'll use the side panel
        },
        plotOptions: {
            scatter: {
                cursor: 'pointer',
                point: {
                    events: {
                        mouseOver: function() {
                            updateTooltipPanel(this);
                        }
                    }
                }
            }
        },
        series: [...baseSeries, ...tagSeries],
        credits: { enabled: false }
    });
    console.log('Main chart created successfully');
    
    // Show most recent photo in tooltip on load
    showMostRecentInTooltip();
    } catch (e) {
        console.error('Error creating main chart:', e);
    }
}

function showMostRecentInTooltip() {
    if (dashboardPhotos.length > 0) {
        const mostRecent = dashboardPhotos.reduce((latest, photo) => {
            const photoDate = new Date(photo.dateStr + 'T' + photo.timeStr);
            const latestDate = new Date(latest.dateStr + 'T' + latest.timeStr);
            return photoDate > latestDate ? photo : latest;
        });
        
        // Create a mock point object for updateTooltipPanel
        const mockPoint = {
            x: mostRecent.dateMs,
            y: mostRecent.timeMs,
            camera: mostRecent.camera,
            photoUrl: mostRecent.photoUrl,
            location: mostRecent.location,
            label: mostRecent.label,
            windSpeed: mostRecent.windSpeed,
            windDirection: mostRecent.windDirection
        };
        updateTooltipPanel(mockPoint);
    }
}

function createPolarChart() {
    const doeData = tagArrays['doe'] || [];
    const buckData = tagArrays['buck'] || [];
    const { doeSegments, buckSegments } = calculateSunRelativeDistribution(doeData, buckData);
    
    Highcharts.chart('chart_polar', {
        chart: {
            polar: true,
            type: 'column',
            backgroundColor: 'transparent'
        },
        accessibility: { enabled: false },
        
        title: {
            text: 'Daylight Activity',
            style: { color: '#E0E0E3' }
        },
        
        pane: {
            startAngle: -90,
            endAngle: 270,
            background: [{
                backgroundColor: 'rgba(255, 255, 200, 0.3)',
                borderWidth: 0,
                outerRadius: '100%',
                innerRadius: '0%',
                shape: 'arc',
                from: 0,
                to: 180
            }, {
                backgroundColor: 'rgba(50, 50, 80, 0.4)',
                borderWidth: 0,
                outerRadius: '100%',
                innerRadius: '0%',
                shape: 'arc',
                from: 180,
                to: 360
            }]
        },
        
        xAxis: {
            tickInterval: 15,
            min: 0,
            max: 360,
            labels: {
                useHTML: true,
                formatter: function() {
                    const index = this.value / 15;
                    if (index === 0) return '<b style="font-size:24px;"></b>';
                    if (index === 6) return '<b style="color:#E0E0E3;">Midday</b>';
                    if (index === 12) return '<b style="font-size:32px;"></b>';
                    if (index === 18) return '<b style="color:#E0E0E3;">Midnight</b>';
                    return '';
                },
                style: { color: '#E0E0E3', fontSize: '12px' }
            },
            gridLineColor: '#444'
        },
        
        yAxis: {
            min: 0,
            labels: { enabled: false },
            gridLineColor: '#444'
        },
        
        plotOptions: {
            column: {
                pointPadding: 0,
                groupPadding: 0.1,
                pointPlacement: 'between'
            },
            series: {
                pointStart: 0,
                pointInterval: 15
            }
        },
        
        legend: {
            enabled: true,
            itemStyle: { color: '#E0E0E3' }
        },
        
        tooltip: {
            shared: true,
            formatter: function() {
                const segment = Math.floor(this.points ? this.points[0].point.index : this.point.index);
                let label;
                if (segment < 12) {
                    const hoursAfterSunrise = segment;
                    if (hoursAfterSunrise === 0) label = ' Sunrise';
                    else label = ` +${hoursAfterSunrise}/12`;
                } else {
                    const hoursAfterSunset = segment - 12;
                    if (hoursAfterSunset === 0) label = ' Sunset';
                    else label = ` +${hoursAfterSunset}/12`;
                }
                
                const chart = this.points ? this.points[0].series.chart : this.series.chart;
                const doeCount = chart.series[0].data[segment]?.y || 0;
                const buckCount = chart.series[1].data[segment]?.y || 0;
                const total = doeCount + buckCount;
                
                return `<b>${label}</b><br/>` +
                       `<span style="color: #1C86EE;"></span> Doe: <b>${doeCount}</b><br/>` +
                       `<span style="color: #FF4444;"></span> Buck: <b>${buckCount}</b><br/>` +
                       `Total: <b>${total}</b>`;
            }
        },
        
        series: [{
            name: 'Doe',
            color: '#1C86EE',
            data: doeSegments
        }, {
            name: 'Buck',
            color: '#FF4444',
            data: buckSegments
        }],
        
        credits: { enabled: false }
    });
}

function updatePolarChart() {
    const doeData = tagArrays['doe'] || [];
    const buckData = tagArrays['buck'] || [];
    updatePolarChartFiltered(doeData, buckData);
}

function updatePolarChartFiltered(doeData, buckData) {
    const { doeSegments, buckSegments } = calculateSunRelativeDistribution(doeData, buckData);
    
    const chart = Highcharts.charts.find(c => c && c.renderTo && c.renderTo.id === 'chart_polar');
    if (chart) {
        chart.series[0].setData(doeSegments, false);
        chart.series[1].setData(buckSegments, false);
        chart.redraw();
    }
}

function calculateSunRelativeDistribution(doeData, buckData) {
    const doeSegments = new Array(24).fill(0);
    const buckSegments = new Array(24).fill(0);
    const DAY_MS = 24 * 60 * 60 * 1000;
    
    function getSegment(timeMs, sunrise, sunset) {
        if (!sunrise || !sunset || sunrise >= sunset) {
            sunrise = 7 * 60 * 60 * 1000;
            sunset = 18 * 60 * 60 * 1000;
        }
        
        const dayLength = sunset - sunrise;
        const nightLength = DAY_MS - dayLength;
        
        if (timeMs >= sunrise && timeMs < sunset) {
            const positionInDay = (timeMs - sunrise) / dayLength;
            return Math.min(11, Math.floor(positionInDay * 12));
        } else {
            let timeSinceSunset;
            if (timeMs >= sunset) {
                timeSinceSunset = timeMs - sunset;
            } else {
                timeSinceSunset = (DAY_MS - sunset) + timeMs;
            }
            const positionInNight = timeSinceSunset / nightLength;
            return 12 + Math.min(11, Math.floor(positionInNight * 12));
        }
    }
    
    doeData.forEach(point => {
        const photo = dashboardPhotos.find(p => p.photoId === point.photoId);
        if (photo) {
            const sun = sunData[photo.dateStr] || {};
            const segment = getSegment(point.y, sun.sunrise, sun.sunset);
            doeSegments[segment]++;
        }
    });
    
    buckData.forEach(point => {
        const photo = dashboardPhotos.find(p => p.photoId === point.photoId);
        if (photo) {
            const sun = sunData[photo.dateStr] || {};
            const segment = getSegment(point.y, sun.sunrise, sun.sunset);
            buckSegments[segment]++;
        }
    });
    
    return { doeSegments, buckSegments };
}

// ============== COMBINED SCATTER POLAR CHART ==============
let combinedScatterChart;

function getScatterFilteredPhotos() {
    const filter = document.getElementById('scatterAnimalFilter')?.value || 'all';
    if (filter === 'all') return dashboardPhotos;
    return dashboardPhotos.filter(p => p.animalType === filter);
}

function normalizeValue(value, min, max) {
    if (max === min) return 0.5;
    return (value - min) / (max - min);
}

function getPhotoRange(photos, field) {
    const values = photos.map(p => p[field]).filter(v => v !== '' && v !== undefined && v !== null && !isNaN(v));
    if (values.length === 0) return { min: 0, max: 1 };
    return { min: Math.min(...values), max: Math.max(...values) };
}

function timeToSunAngle(photo) {
    const sun = sunData[photo.dateStr] || {};
    const sunrise = sun.sunrise || 7 * 60 * 60 * 1000;
    const sunset = sun.sunset || 18 * 60 * 60 * 1000;
    const DAY_MS = 24 * 60 * 60 * 1000;
    const timeMs = photo.timeMs;
    
    const dayLength = sunset - sunrise;
    const nightLength = DAY_MS - dayLength;
    
    if (timeMs >= sunrise && timeMs < sunset) {
        const positionInDay = (timeMs - sunrise) / dayLength;
        return positionInDay * 180;
    } else {
        let timeSinceSunset;
        if (timeMs >= sunset) {
            timeSinceSunset = timeMs - sunset;
        } else {
            timeSinceSunset = (DAY_MS - sunset) + timeMs;
        }
        const positionInNight = timeSinceSunset / nightLength;
        return 180 + positionInNight * 180;
    }
}

function buildScatterSeriesData(photos) {
    const tempRange = getPhotoRange(photos, 'tempMax');
    const pressureRange = getPhotoRange(photos, 'barometricPressure');
    const windSpeedRange = getPhotoRange(photos, 'windSpeed');
    
    // Scatter: angle = sun-relative time, radius = normalized value
    const tempScatter = photos.filter(p => p.tempMax !== '' && p.tempMax !== undefined).map(p => ({
        x: timeToSunAngle(p),
        y: 0.15 + normalizeValue(p.tempMax, tempRange.min, tempRange.max) * 0.8,
        temp: p.tempMax,
        animal: p.animalType
    }));
    
    const pressureScatter = photos.filter(p => p.barometricPressure !== '' && p.barometricPressure !== undefined).map(p => ({
        x: timeToSunAngle(p),
        y: 0.15 + normalizeValue(p.barometricPressure, pressureRange.min, pressureRange.max) * 0.8,
        pressure: p.barometricPressure,
        animal: p.animalType
    }));
    
    const windSpeedScatter = photos.filter(p => p.windSpeed !== '' && p.windSpeed !== undefined).map(p => ({
        x: timeToSunAngle(p),
        y: 0.15 + normalizeValue(p.windSpeed, windSpeedRange.min, windSpeedRange.max) * 0.8,
        windSpeed: p.windSpeed,
        animal: p.animalType
    }));
    
    // Wind Direction: angle = compass direction
    const windDirScatter = photos.filter(p => p.windDirection !== '' && p.windDirection !== undefined).map(p => ({
        x: p.windDirection,
        y: 0.3 + Math.random() * 0.5,
        windDir: p.windDirection,
        animal: p.animalType
    }));
    
    // Time of Day: angle = sun-relative time
    const timeScatter = photos.map(p => ({
        x: timeToSunAngle(p),
        y: 0.3 + Math.random() * 0.5,
        hour: p.timeMs / (60 * 60 * 1000),
        animal: p.animalType
    }));
    
    // Moon Phase: angle = phase position (need to get from sunData)
    const moonScatter = photos.map(p => {
        const sun = sunData[p.dateStr] || {};
        const moonPhase = sun.moonphase || 0;
        return {
            x: moonPhase * 360,
            y: 0.3 + Math.random() * 0.5,
            moonPhase: moonPhase,
            animal: p.animalType
        };
    });
    
    return { tempScatter, pressureScatter, windSpeedScatter, windDirScatter, timeScatter, moonScatter };
}

function createCombinedScatterChart() {
    const photos = getScatterFilteredPhotos();
    if (photos.length === 0) return;
    
    const data = buildScatterSeriesData(photos);
    
    combinedScatterChart = Highcharts.chart('chart_combined_scatter', {
        chart: {
            polar: true,
            backgroundColor: 'transparent',
            animation: false
        },
        accessibility: { enabled: false },
        
        title: {
            text: 'Weather & Activity Correlation',
            style: { color: '#E0E0E3' }
        },
        
        pane: {
            startAngle: -90,
            endAngle: 270,
            background: [{
                backgroundColor: 'rgba(255, 255, 200, 0.15)',
                borderWidth: 0,
                outerRadius: '100%',
                innerRadius: '0%',
                shape: 'arc',
                from: 0,
                to: 180
            }, {
                backgroundColor: 'rgba(50, 50, 80, 0.25)',
                borderWidth: 0,
                outerRadius: '100%',
                innerRadius: '0%',
                shape: 'arc',
                from: 180,
                to: 360
            }]
        },
        
        xAxis: {
            tickInterval: 15,
            min: 0,
            max: 360,
            labels: {
                formatter: function() {
                    const seg = this.value / 15;
                    if (seg === 0) return '';
                    if (seg === 6) return 'Midday';
                    if (seg === 12) return '';
                    if (seg === 18) return 'Midnight';
                    return '';
                },
                style: { color: '#E0E0E3', fontSize: '11px' }
            },
            gridLineColor: '#444'
        },
        
        yAxis: {
            min: 0,
            max: 1,
            labels: { enabled: false },
            gridLineColor: '#333'
        },
        
        plotOptions: {
            scatter: {
                marker: {
                    radius: 4,
                    states: { hover: { enabled: true, radius: 6 } }
                }
            },
            series: { animation: false }
        },
        
        series: [
            {
                type: 'scatter', name: 'Temperature', id: 'scatter_temp',
                data: data.tempScatter, color: '#FF6B6B', marker: { symbol: 'circle' },
                visible: document.getElementById('scatter_temp')?.checked ?? true,
                tooltip: { pointFormatter: function() { return `<b>Temp:</b> ${this.temp}F<br/><b>Animal:</b> ${this.animal}`; } }
            },
            {
                type: 'scatter', name: 'Pressure', id: 'scatter_pressure',
                data: data.pressureScatter, color: '#AF7AC5', marker: { symbol: 'circle' },
                visible: document.getElementById('scatter_pressure')?.checked ?? true,
                tooltip: { pointFormatter: function() { return `<b>Pressure:</b> ${this.pressure} inHg<br/><b>Animal:</b> ${this.animal}`; } }
            },
            {
                type: 'scatter', name: 'Wind Speed', id: 'scatter_windspeed',
                data: data.windSpeedScatter, color: '#5DADE2', marker: { symbol: 'circle' },
                visible: document.getElementById('scatter_windspeed')?.checked ?? true,
                tooltip: { pointFormatter: function() { return `<b>Wind Speed:</b> ${this.windSpeed} mph<br/><b>Animal:</b> ${this.animal}`; } }
            },
            {
                type: 'scatter', name: 'Wind Direction', id: 'scatter_winddir',
                data: data.windDirScatter, color: '#7FB3D5', marker: { symbol: 'diamond' },
                visible: document.getElementById('scatter_winddir')?.checked ?? false,
                tooltip: { pointFormatter: function() { return `<b>Wind Dir:</b> ${getWindDirection(this.windDir)}<br/><b>Animal:</b> ${this.animal}`; } }
            },
            {
                type: 'scatter', name: 'Time of Day', id: 'scatter_timeofday',
                data: data.timeScatter, color: '#F4D03F', marker: { symbol: 'triangle' },
                visible: document.getElementById('scatter_timeofday')?.checked ?? false,
                tooltip: { pointFormatter: function() { 
                    const h = Math.floor(this.hour); const m = Math.floor((this.hour - h) * 60);
                    return `<b>Time:</b> ${h}:${m.toString().padStart(2,'0')}<br/><b>Animal:</b> ${this.animal}`; 
                } }
            },
            {
                type: 'scatter', name: 'Moon Phase', id: 'scatter_moonphase',
                data: data.moonScatter, color: '#D4AC0D', marker: { symbol: 'circle' },
                visible: document.getElementById('scatter_moonphase')?.checked ?? false,
                tooltip: { pointFormatter: function() { return `<b>Moon:</b> ${getMoonPhaseName(this.moonPhase)}<br/><b>Animal:</b> ${this.animal}`; } }
            }
        ],
        
        legend: { enabled: false },
        
        tooltip: {
            backgroundColor: 'rgba(40, 40, 40, 0.95)',
            style: { color: '#E0E0E3' },
            borderColor: '#555'
        },
        
        credits: { enabled: false }
    });
}

function updateCombinedScatterChart() {
    if (!combinedScatterChart) {
        createCombinedScatterChart();
        return;
    }
    
    const photos = getScatterFilteredPhotos();
    const data = buildScatterSeriesData(photos);
    
    combinedScatterChart.get('scatter_temp')?.setData(data.tempScatter, false);
    combinedScatterChart.get('scatter_pressure')?.setData(data.pressureScatter, false);
    combinedScatterChart.get('scatter_windspeed')?.setData(data.windSpeedScatter, false);
    combinedScatterChart.get('scatter_winddir')?.setData(data.windDirScatter, false);
    combinedScatterChart.get('scatter_timeofday')?.setData(data.timeScatter, false);
    combinedScatterChart.get('scatter_moonphase')?.setData(data.moonScatter, false);
    
    combinedScatterChart.get('scatter_temp')?.setVisible(document.getElementById('scatter_temp')?.checked ?? false, false);
    combinedScatterChart.get('scatter_pressure')?.setVisible(document.getElementById('scatter_pressure')?.checked ?? false, false);
    combinedScatterChart.get('scatter_windspeed')?.setVisible(document.getElementById('scatter_windspeed')?.checked ?? false, false);
    combinedScatterChart.get('scatter_winddir')?.setVisible(document.getElementById('scatter_winddir')?.checked ?? false, false);
    combinedScatterChart.get('scatter_timeofday')?.setVisible(document.getElementById('scatter_timeofday')?.checked ?? false, false);
    combinedScatterChart.get('scatter_moonphase')?.setVisible(document.getElementById('scatter_moonphase')?.checked ?? false, false);
    
    combinedScatterChart.redraw();
}

function createWeatherChart() {
    const field = currentWeatherField || 'windDirection';
    const { categories, dayCounts, nightCounts, title } = calculateWeatherDistribution(field);
    
    Highcharts.chart('chart_weather', {
        chart: {
            type: 'column',
            backgroundColor: 'transparent',
            marginTop: 50
        },
        accessibility: { enabled: false },
        
        title: {
            text: null
        },
        
        xAxis: {
            categories: categories,
            labels: {
                style: { color: '#E0E0E3' },
                rotation: categories.length > 10 ? -45 : 0
            },
            lineColor: '#555',
            tickColor: '#555'
        },
        
        yAxis: {
            min: 0,
            title: {
                text: 'Photo Count',
                style: { color: '#E0E0E3' }
            },
            labels: {
                style: { color: '#E0E0E3' }
            },
            gridLineColor: '#444'
        },
        
        legend: {
            enabled: true,
            itemStyle: { color: '#E0E0E3' },
            itemHoverStyle: { color: '#fff' }
        },
        
        tooltip: {
            shared: true,
            backgroundColor: 'rgba(40, 40, 40, 0.9)',
            style: { color: '#E0E0E3' }
        },
        
        plotOptions: {
            column: {
                grouping: true,
                shadow: false,
                borderWidth: 0
            }
        },
        
        series: [{
            name: 'Daytime',
            color: '#F4D03F',
            data: dayCounts
        }, {
            name: 'Nighttime',
            color: '#5D6D7E',
            data: nightCounts
        }],
        
        credits: { enabled: false }
    });
}

let currentWeatherField = 'windDirection';

function selectWeatherField(field) {
    currentWeatherField = field;
    // Update button states
    const btnIds = {
        'windDirection': 'btnWindDirection',
        'windSpeed': 'btnWindSpeed', 
        'temperature': 'btnTemperature',
        'pressure': 'btnPressure',
        'moonPhase': 'btnMoonPhase'
    };
    Object.values(btnIds).forEach(id => {
        document.getElementById(id)?.classList.remove('active');
    });
    document.getElementById(btnIds[field])?.classList.add('active');
    updateWeatherChart();
}

function updateWeatherChart() {
    const field = currentWeatherField;
    const { categories, dayCounts, nightCounts } = calculateWeatherDistribution(field);
    
    const chart = Highcharts.charts.find(c => c && c.renderTo && c.renderTo.id === 'chart_weather');
    if (chart) {
        chart.xAxis[0].setCategories(categories);
        chart.series[0].setData(dayCounts, false);
        chart.series[1].setData(nightCounts, false);
        chart.redraw();
    }
}

function calculateWeatherDistribution(field) {
    let categories, dayCounts, nightCounts, title;
    
    // Get current filter values from unified filters
    const cameraFilter = document.getElementById('cameraFilter')?.value || '';
    const locationFilter = document.getElementById('locationFilter')?.value || '';
    const tagFilter = document.getElementById('tagFilter')?.value || '';
    
    // Map tag filter to type
    const tagToType = {
        'Buck': 'buck', 'Doe': 'doe', 'Turkey': 'turkey', 'Bear': 'bear',
        'Predator': 'predator', 'Bird': 'bird', 'Human': 'human',
        'Vehicle/ATV': 'vehicle', 'Other': 'other_tagged', 'No Animals': 'no_animals'
    };
    const filterType = tagFilter && tagFilter !== 'untagged' ? tagToType[tagFilter] : null;
    
    // Filter photos based on current filters
    const filteredPhotos = dashboardPhotos.filter(photo => {
        if (cameraFilter && photo.camera !== cameraFilter) return false;
        if (locationFilter && photo.location !== locationFilter) return false;
        if (filterType && photo.animalType !== filterType) return false;
        return true;
    });
    
    // Helper to determine if photo is daytime
    function isDaytime(photo) {
        const sun = sunData[photo.dateStr] || {};
        if (!sun.sunrise || !sun.sunset) return true;
        return photo.timeMs >= sun.sunrise && photo.timeMs < sun.sunset;
    }
    
    switch (field) {
        case 'windDirection':
            categories = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
            title = 'Photos by Wind Direction';
            const dayWindDir = new Array(8).fill(0);
            const nightWindDir = new Array(8).fill(0);
            
            filteredPhotos.forEach(photo => {
                if (photo.windDirection === '' || photo.windDirection === null || photo.windDirection === undefined) return;
                const idx = Math.round(photo.windDirection / 45) % 8;
                if (isDaytime(photo)) dayWindDir[idx]++;
                else nightWindDir[idx]++;
            });
            dayCounts = dayWindDir;
            nightCounts = nightWindDir;
            break;
            
        case 'windSpeed':
            categories = ['0-3', '3-6', '6-9', '9-12', '12-15', '15+'];
            title = 'Photos by Wind Speed (MPH)';
            const dayWindSpd = new Array(6).fill(0);
            const nightWindSpd = new Array(6).fill(0);
            
            filteredPhotos.forEach(photo => {
                if (photo.windSpeed === '' || photo.windSpeed === null || photo.windSpeed === undefined) return;
                const speed = parseFloat(photo.windSpeed);
                let idx;
                if (speed < 3) idx = 0;
                else if (speed < 6) idx = 1;
                else if (speed < 9) idx = 2;
                else if (speed < 12) idx = 3;
                else if (speed < 15) idx = 4;
                else idx = 5;
                if (isDaytime(photo)) dayWindSpd[idx]++;
                else nightWindSpd[idx]++;
            });
            dayCounts = dayWindSpd;
            nightCounts = nightWindSpd;
            break;
            
        case 'temperature':
            categories = ['<20', '20', '25', '30', '35', '40', '45', '50', '55', '60', '65', '70', '75', '80', '85', '90+'];
            title = 'Photos by Temperature (F)';
            const dayTemp = new Array(16).fill(0);
            const nightTemp = new Array(16).fill(0);
            
            filteredPhotos.forEach(photo => {
                let temp = null;
                if (photo.tempMin !== undefined && photo.tempMax !== undefined) {
                    temp = (parseFloat(photo.tempMin) + parseFloat(photo.tempMax)) / 2;
                } else if (photo.tempMin !== undefined) {
                    temp = parseFloat(photo.tempMin);
                } else if (photo.tempMax !== undefined) {
                    temp = parseFloat(photo.tempMax);
                }
                if (temp === null || isNaN(temp)) return;
                
                let idx;
                if (temp < 20) idx = 0;
                else if (temp < 25) idx = 1;
                else if (temp < 30) idx = 2;
                else if (temp < 35) idx = 3;
                else if (temp < 40) idx = 4;
                else if (temp < 45) idx = 5;
                else if (temp < 50) idx = 6;
                else if (temp < 55) idx = 7;
                else if (temp < 60) idx = 8;
                else if (temp < 65) idx = 9;
                else if (temp < 70) idx = 10;
                else if (temp < 75) idx = 11;
                else if (temp < 80) idx = 12;
                else if (temp < 85) idx = 13;
                else if (temp < 90) idx = 14;
                else idx = 15;
                if (isDaytime(photo)) dayTemp[idx]++;
                else nightTemp[idx]++;
            });
            dayCounts = dayTemp;
            nightCounts = nightTemp;
            break;
            
        case 'pressure':
            categories = ['<29.50', '29.50', '29.55', '29.60', '29.65', '29.70', '29.75', '29.80', '29.85', '29.90', '29.95', '30.00', '30.05', '30.10', '30.15', '30.20', '30.25', '30.30', '30.35', '30.40', '30.45', '30.50'];
            title = 'Photos by Barometric Pressure (inHg)';
            const dayPres = new Array(22).fill(0);
            const nightPres = new Array(22).fill(0);
            
            filteredPhotos.forEach(photo => {
                if (photo.barometricPressure === '' || photo.barometricPressure === null || photo.barometricPressure === undefined) return;
                const pressure = parseFloat(photo.barometricPressure);
                if (isNaN(pressure)) return;
                let idx;
                if (pressure < 29.50) idx = 0;
                else if (pressure >= 30.50) idx = 21;
                else idx = Math.floor((pressure - 29.50) / 0.05) + 1;
                if (isDaytime(photo)) dayPres[idx]++;
                else nightPres[idx]++;
            });
            dayCounts = dayPres;
            nightCounts = nightPres;
            break;
            
        case 'moonPhase':
            categories = [' New', ' Wax Cres', ' 1st Qtr', ' Wax Gib', ' Full', ' Wan Gib', ' 3rd Qtr', ' Wan Cres'];
            title = 'Photos by Moon Phase';
            const dayMoon = new Array(8).fill(0);
            const nightMoon = new Array(8).fill(0);
            
            filteredPhotos.forEach(photo => {
                const sun = sunData[photo.dateStr] || {};
                if (sun.moonphase === '' || sun.moonphase === null || sun.moonphase === undefined) return;
                const phase = parseFloat(sun.moonphase);
                let idx;
                if (phase < 0.0625) idx = 0;
                else if (phase < 0.1875) idx = 1;
                else if (phase < 0.3125) idx = 2;
                else if (phase < 0.4375) idx = 3;
                else if (phase < 0.5625) idx = 4;
                else if (phase < 0.6875) idx = 5;
                else if (phase < 0.8125) idx = 6;
                else if (phase < 0.9375) idx = 7;
                else idx = 0;
                if (isDaytime(photo)) dayMoon[idx]++;
                else nightMoon[idx]++;
            });
            dayCounts = dayMoon;
            nightCounts = nightMoon;
            break;
            
        default:
            categories = [];
            dayCounts = [];
            nightCounts = [];
            title = 'Weather Distribution';
    }
    
    return { categories, dayCounts, nightCounts, title };
}

// ============== FORECAST CHART ==============
async function loadForecast() {
    try {
        let data = cachedForecastData;
        
        // Fetch if not cached
        if (!data) {
            const lat = CONFIG.fixedLat;
            const lng = CONFIG.fixedLng;
            
            const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&daily=temperature_2m_max,temperature_2m_min,precipitation_probability_max,wind_speed_10m_max,wind_direction_10m_dominant&hourly=surface_pressure&current=temperature_2m,relative_humidity_2m,wind_speed_10m,wind_direction_10m,wind_gusts_10m,surface_pressure,precipitation&temperature_unit=fahrenheit&wind_speed_unit=mph&timezone=America%2FNew_York&forecast_days=10`;
            
            const response = await fetch(url);
            
            if (!response.ok) {
                showForecastError('Could not load forecast');
                return;
            }
            
            data = await response.json();
        }
        
        if (data.current) {
            updateCurrentConditions(data.current);
        }
        
        if (data.daily && data.daily.time && data.daily.time.length > 0) {
            const dailyPressure = [];
            if (data.hourly && data.hourly.surface_pressure) {
                for (let d = 0; d < data.daily.time.length; d++) {
                    const dayStart = d * 24;
                    const dayPressures = data.hourly.surface_pressure.slice(dayStart, dayStart + 24);
                    const avgPressure = dayPressures.reduce((a, b) => a + b, 0) / dayPressures.length;
                    dailyPressure.push((avgPressure / 33.864).toFixed(2));
                }
            }
            
            const days = data.daily.time.map((date, i) => ({
                datetime: date,
                tempmax: data.daily.temperature_2m_max[i],
                tempmin: data.daily.temperature_2m_min[i],
                windspeed: data.daily.wind_speed_10m_max[i],
                winddir: data.daily.wind_direction_10m_dominant[i],
                precipprob: data.daily.precipitation_probability_max[i],
                pressure: dailyPressure[i] || null,
                moonphase: calculateMoonPhase(date)
            }));
            
            forecastDays = days;
            createForecastChart(days);
            createPredictionChart();
            updateOptimalConditions();
        } else {
            showForecastError('No forecast data available');
        }
    } catch (error) {
        console.error('Error loading forecast:', error);
        showForecastError('Could not load forecast');
    }
}

function updateCurrentConditions(current) {
    const pressure = (current.surface_pressure / 33.864).toFixed(2);
    const windDir = getWindDirection(current.wind_direction_10m);
    
    // Get current moon phase
    const today = new Date();
    const todayStr = today.toISOString().split('T')[0];
    const sun = sunData[todayStr] || {};
    const moonPhase = sun.moonphase !== undefined ? sun.moonphase : calculateMoonPhase(today).phase;
    const moonSymbol = getMoonSymbol(moonPhase);
    const moonName = getMoonPhaseName(moonPhase);
    
    const container = document.getElementById('currentConditions');
    container.innerHTML = `
        <span><span style="color: #F4D03F;">Temp:</span> ${Math.round(current.temperature_2m)}F</span>
        <span><span style="color: #AF7AC5;">Press:</span> ${pressure}</span>
        <span><span style="color: #7FB3D5;">Wind:</span> ${windDir} at ${Math.round(current.wind_speed_10m)}mph</span>
        <span><span style="color: #D4AC0D;">Moon:</span> ${moonSymbol} ${moonName}</span>
    `;
}

function showForecastError(message) {
    const container = document.getElementById('chart_forecast');
    container.innerHTML = `<div class="d-flex align-items-center justify-content-center h-100 text-muted">
        <div class="text-center">
            <i class="bi bi-cloud-slash" style="font-size: 2rem;"></i>
            <p class="mt-2 mb-0">${message}</p>
        </div>
    </div>`;
}

function createForecastChart(days) {
    const categories = days.map(d => {
        const date = new Date(d.datetime + 'T12:00:00');
        return Highcharts.dateFormat('%a %m/%d', date);
    });
    
    const tempMax = days.map(d => d.tempmax);
    const tempMin = days.map(d => d.tempmin);
    const windSpeed = days.map(d => d.windspeed);
    const precipProb = days.map(d => d.precipprob);
    const pressure = days.map(d => d.pressure);
    const windDir = days.map(d => typeof d.winddir === 'string' ? d.winddir : getWindDirection(d.winddir));
    const moonPhase = days.map(d => getMoonSymbol(d.moonphase));
    
    Highcharts.chart('chart_forecast', {
        chart: {
            backgroundColor: 'transparent',
            height: 300
        },
        accessibility: { enabled: false },
        
        title: {
            text: '10-Day Forecast - ' + CONFIG.fixedLocationName,
            style: { color: '#E0E0E3' }
        },
        
        xAxis: {
            categories: categories,
            labels: {
                style: { color: '#E0E0E3' }
            },
            lineColor: '#555',
            tickColor: '#555'
        },
        
        yAxis: [{
            title: {
                text: 'Temperature (F)',
                style: { color: '#E0E0E3' }
            },
            labels: {
                style: { color: '#E0E0E3' },
                format: '{value}'
            },
            gridLineColor: '#444'
        }, {
            title: {
                text: 'Wind (MPH) / Precip (%)',
                style: { color: '#E0E0E3' }
            },
            labels: {
                style: { color: '#E0E0E3' }
            },
            opposite: true,
            min: 0,
            gridLineWidth: 0
        }],
        
        legend: {
            enabled: true,
            itemStyle: { color: '#E0E0E3' },
            itemHoverStyle: { color: '#fff' }
        },
        
        tooltip: {
            shared: true,
            backgroundColor: 'rgba(40, 40, 40, 0.95)',
            style: { color: '#E0E0E3' },
            useHTML: true,
            positioner: function(labelWidth, labelHeight, point) {
                let x = point.plotX + this.chart.plotLeft + 15;
                let y = point.plotY + this.chart.plotTop - labelHeight - 10;
                
                // Keep tooltip from going above chart
                if (y < 0) y = 10;
                
                // Keep tooltip from going past right edge
                if (x + labelWidth > this.chart.chartWidth) {
                    x = point.plotX + this.chart.plotLeft - labelWidth - 15;
                }
                
                return { x: x, y: y };
            },
            formatter: function() {
                const idx = this.points[0].point.index;
                const day = days[idx];
                const date = new Date(day.datetime + 'T12:00:00');
                const dateStr = Highcharts.dateFormat('%a, %b. %e', date);
                let html = `<b>${dateStr}</b><br/>`;
                html += `<span style="color:#F4D03F">Temp:</span> ${Math.round(day.tempmin)} - ${Math.round(day.tempmax)}F<br/>`;
                html += `<span style="color:#AF7AC5">Press:</span> ${day.pressure} inHg<br/>`;
                html += `<span style="color:#7FB3D5">Wind:</span> ${getWindDirection(day.winddir)} at ${Math.round(day.windspeed)}mph<br/>`;
                html += `<span style="color:#D4AC0D">Moon:</span> ${getMoonSymbol(day.moonphase)} ${getMoonPhaseName(day.moonphase)}`;
                return html;
            }
        },
        
        plotOptions: {
            series: {
                marker: {
                    enabled: true,
                    radius: 4
                }
            }
        },
        
        series: [{
            name: 'High Temp',
            type: 'spline',
            color: '#FF6B6B',
            data: tempMax,
            yAxis: 0,
            tooltip: { valueSuffix: 'F' }
        }, {
            name: 'Low Temp',
            type: 'spline',
            color: '#4ECDC4',
            data: tempMin,
            yAxis: 0,
            tooltip: { valueSuffix: 'F' }
        }, {
            name: 'Wind Speed',
            type: 'column',
            color: 'rgba(100, 149, 237, 0.7)',
            data: windSpeed,
            yAxis: 1,
            tooltip: { valueSuffix: ' MPH' }
        }, {
            name: 'Precip Chance',
            type: 'area',
            color: 'rgba(135, 206, 250, 0.3)',
            lineColor: 'rgba(135, 206, 250, 0.8)',
            data: precipProb,
            yAxis: 1,
            tooltip: { valueSuffix: '%' }
        }],
        
        credits: { enabled: false }
    });
}

// ============== ACTIVITY PREDICTION ==============
function calculateHistoricalActivityRates(animalFilter, photosToUse = null) {
    // Use provided photos or default to dashboardPhotos
    const sourcePhotos = photosToUse || dashboardPhotos;
    
    // Filter photos for daytime only, by animal type
    const validPhotos = sourcePhotos.filter(photo => {
        const sun = sunData[photo.dateStr] || {};
        if (!sun.sunrise || !sun.sunset) return false;
        if (photo.timeMs < sun.sunrise || photo.timeMs >= sun.sunset) return false;
        
        if (animalFilter === 'buck' && photo.animalType !== 'buck') return false;
        if (animalFilter === 'doe' && photo.animalType !== 'doe') return false;
        if (animalFilter === 'all' && photo.animalType !== 'buck' && photo.animalType !== 'doe') return false;
        
        return true;
    });
    
    const morningPhotos = validPhotos.filter(p => p.timeMs < 12 * 60 * 60 * 1000);
    const eveningPhotos = validPhotos.filter(p => p.timeMs >= 12 * 60 * 60 * 1000);
    
    return {
        total: validPhotos.length,
        morning: morningPhotos.length,
        evening: eveningPhotos.length,
        pressure: calculateBucketRates(validPhotos, 'pressure'),
        pressureMorning: calculateBucketRates(morningPhotos, 'pressure'),
        pressureEvening: calculateBucketRates(eveningPhotos, 'pressure'),
        temp: calculateBucketRates(validPhotos, 'temp'),
        tempMorning: calculateBucketRates(morningPhotos, 'temp'),
        tempEvening: calculateBucketRates(eveningPhotos, 'temp'),
        windDir: calculateBucketRates(validPhotos, 'windDir'),
        windDirMorning: calculateBucketRates(morningPhotos, 'windDir'),
        windDirEvening: calculateBucketRates(eveningPhotos, 'windDir'),
        windSpeed: calculateBucketRates(validPhotos, 'windSpeed'),
        windSpeedMorning: calculateBucketRates(morningPhotos, 'windSpeed'),
        windSpeedEvening: calculateBucketRates(eveningPhotos, 'windSpeed'),
        moonPhase: calculateBucketRates(validPhotos, 'moonPhase'),
        moonPhaseMorning: calculateBucketRates(morningPhotos, 'moonPhase'),
        moonPhaseEvening: calculateBucketRates(eveningPhotos, 'moonPhase')
    };
}

function calculateBucketRates(photos, field) {
    const buckets = getBucketCounts(photos, field);
    const total = photos.length || 1;
    const numBuckets = buckets.length;
    const expectedRate = 1 / numBuckets;
    return buckets.map(count => (count / total) / expectedRate);
}

function getBucketCounts(photos, field) {
    switch (field) {
        case 'pressure':
            const pressure = new Array(22).fill(0);
            photos.forEach(p => {
                if (p.barometricPressure === '' || p.barometricPressure === null || p.barometricPressure === undefined) return;
                const val = parseFloat(p.barometricPressure);
                if (isNaN(val)) return;
                let idx;
                if (val < 29.50) idx = 0;
                else if (val >= 30.50) idx = 21;
                else idx = Math.floor((val - 29.50) / 0.05) + 1;
                pressure[idx]++;
            });
            return pressure;
            
        case 'temp':
            const temp = [0, 0, 0, 0, 0, 0, 0, 0, 0];
            photos.forEach(p => {
                let t = null;
                if (p.tempMin !== '' && p.tempMin !== undefined && p.tempMax !== '' && p.tempMax !== undefined) {
                    t = (parseFloat(p.tempMin) + parseFloat(p.tempMax)) / 2;
                } else if (p.tempMin !== '' && p.tempMin !== undefined) t = parseFloat(p.tempMin);
                else if (p.tempMax !== '' && p.tempMax !== undefined) t = parseFloat(p.tempMax);
                if (t === null || isNaN(t)) return;
                
                if (t < 20) temp[0]++;
                else if (t < 30) temp[1]++;
                else if (t < 40) temp[2]++;
                else if (t < 50) temp[3]++;
                else if (t < 60) temp[4]++;
                else if (t < 70) temp[5]++;
                else if (t < 80) temp[6]++;
                else if (t < 90) temp[7]++;
                else temp[8]++;
            });
            return temp;
            
        case 'windDir':
            const windDir = [0, 0, 0, 0, 0, 0, 0, 0];
            photos.forEach(p => {
                if (p.windDirection === '' || p.windDirection === null || p.windDirection === undefined) return;
                const idx = Math.round(p.windDirection / 45) % 8;
                windDir[idx]++;
            });
            return windDir;
            
        case 'windSpeed':
            const windSpeed = [0, 0, 0, 0, 0, 0];
            photos.forEach(p => {
                if (p.windSpeed === '' || p.windSpeed === null || p.windSpeed === undefined) return;
                const speed = parseFloat(p.windSpeed);
                if (isNaN(speed)) return;
                if (speed < 3) windSpeed[0]++;
                else if (speed < 6) windSpeed[1]++;
                else if (speed < 9) windSpeed[2]++;
                else if (speed < 12) windSpeed[3]++;
                else if (speed < 15) windSpeed[4]++;
                else windSpeed[5]++;
            });
            return windSpeed;
            
        case 'moonPhase':
            const moonPhase = [0, 0, 0, 0, 0, 0, 0, 0];
            photos.forEach(p => {
                const sun = sunData[p.dateStr] || {};
                if (sun.moonphase === '' || sun.moonphase === null || sun.moonphase === undefined) return;
                const phase = parseFloat(sun.moonphase);
                if (phase < 0.0625) moonPhase[0]++;
                else if (phase < 0.1875) moonPhase[1]++;
                else if (phase < 0.3125) moonPhase[2]++;
                else if (phase < 0.4375) moonPhase[3]++;
                else if (phase < 0.5625) moonPhase[4]++;
                else if (phase < 0.6875) moonPhase[5]++;
                else if (phase < 0.8125) moonPhase[6]++;
                else if (phase < 0.9375) moonPhase[7]++;
                else moonPhase[0]++;
            });
            return moonPhase;
            
        default:
            return [];
    }
}

function getForecastBucketIndex(day, field) {
    switch (field) {
        case 'pressure':
            const p = parseFloat(day.pressure);
            if (p < 29.50) return 0;
            if (p >= 30.50) return 21;
            return Math.floor((p - 29.50) / 0.05) + 1;
            
        case 'temp':
            const t = (day.tempmax + day.tempmin) / 2;
            if (t < 20) return 0;
            if (t < 30) return 1;
            if (t < 40) return 2;
            if (t < 50) return 3;
            if (t < 60) return 4;
            if (t < 70) return 5;
            if (t < 80) return 6;
            if (t < 90) return 7;
            return 8;
            
        case 'windDir':
            return Math.round(day.winddir / 45) % 8;
            
        case 'windSpeed':
            const ws = day.windspeed;
            if (ws < 3) return 0;
            if (ws < 6) return 1;
            if (ws < 9) return 2;
            if (ws < 12) return 3;
            if (ws < 15) return 4;
            return 5;
            
        case 'moonPhase':
            const mp = day.moonphase;
            if (mp < 0.0625) return 0;
            if (mp < 0.1875) return 1;
            if (mp < 0.3125) return 2;
            if (mp < 0.4375) return 3;
            if (mp < 0.5625) return 4;
            if (mp < 0.6875) return 5;
            if (mp < 0.8125) return 6;
            if (mp < 0.9375) return 7;
            return 0;
            
        default:
            return 0;
    }
}

function updateWeightSlider(changedSlider) {
    const sliderIds = ['weightPressure', 'weightWindDir', 'weightWindSpeed', 'weightMoon', 'weightTemp'];
    const sliders = sliderIds.map(id => document.getElementById(id));
    const changedId = changedSlider.id;
    
    // Get current values
    let values = {};
    sliders.forEach(s => {
        values[s.id] = parseInt(s.value);
    });
    
    // Calculate total
    let total = Object.values(values).reduce((a, b) => a + b, 0);
    
    // If total exceeds 100, reduce other sliders
    if (total > 100) {
        const excess = total - 100;
        const otherSliderIds = sliderIds.filter(id => id !== changedId);
        const otherSliders = otherSliderIds.map(id => document.getElementById(id));
        
        // Get sum of other sliders
        let otherTotal = otherSliderIds.reduce((sum, id) => sum + values[id], 0);
        
        if (otherTotal > 0) {
            // Distribute reduction proportionally
            let remainingExcess = excess;
            
            // Sort other sliders by value descending so we reduce larger ones first
            otherSliders.sort((a, b) => parseInt(b.value) - parseInt(a.value));
            
            for (let slider of otherSliders) {
                if (remainingExcess <= 0) break;
                
                const currentVal = parseInt(slider.value);
                const proportion = currentVal / otherTotal;
                let reduction = Math.ceil(excess * proportion);
                
                // Round to nearest 5
                reduction = Math.round(reduction / 5) * 5;
                if (reduction < 5 && currentVal >= 5) reduction = 5;
                
                const newVal = Math.max(0, currentVal - reduction);
                const actualReduction = currentVal - newVal;
                
                slider.value = newVal;
                values[slider.id] = newVal;
                remainingExcess -= actualReduction;
            }
            
            // If still over 100, do another pass
            total = Object.values(values).reduce((a, b) => a + b, 0);
            while (total > 100) {
                for (let slider of otherSliders) {
                    if (total <= 100) break;
                    const currentVal = parseInt(slider.value);
                    if (currentVal >= 5) {
                        slider.value = currentVal - 5;
                        values[slider.id] = currentVal - 5;
                        total -= 5;
                    }
                }
                // Safety check to prevent infinite loop
                const newTotal = Object.values(values).reduce((a, b) => a + b, 0);
                if (newTotal >= total) break;
                total = newTotal;
            }
        }
    }
    
    // Update all value displays
    sliderIds.forEach(id => {
        const valueSpan = document.getElementById(id + 'Value');
        if (valueSpan) {
            valueSpan.textContent = values[id] + '%';
        }
    });
    
    // Update total display
    total = Object.values(values).reduce((a, b) => a + b, 0);
    const totalDisplay = document.getElementById('totalWeightDisplay');
    if (totalDisplay) {
        totalDisplay.textContent = `Total: ${total}%`;
        totalDisplay.style.color = total === 100 ? '#4CAF50' : '#FFC107';
    }
    
    // Update the prediction chart
    updatePredictionChart();
}

function calculateActivityScore(day, rates, period = 'all') {
    const weights = {
        pressure: parseInt(document.getElementById('weightPressure')?.value) || 30,
        temp: parseInt(document.getElementById('weightTemp')?.value) || 10,
        windDir: parseInt(document.getElementById('weightWindDir')?.value) || 20,
        windSpeed: parseInt(document.getElementById('weightWindSpeed')?.value) || 20,
        moonPhase: parseInt(document.getElementById('weightMoon')?.value) || 20
    };
    
    const totalWeight = Object.values(weights).reduce((a, b) => a + b, 0);
    const totalDisplay = document.getElementById('totalWeightDisplay');
    if (totalDisplay) {
        totalDisplay.textContent = `Total: ${totalWeight}%`;
        totalDisplay.style.color = totalWeight === 100 ? '#4CAF50' : '#FFC107';
    }
    
    const suffix = period === 'morning' ? 'Morning' : period === 'evening' ? 'Evening' : '';
    
    let totalScore = 0;
    let maxPossible = 0;
    
    for (const [field, weight] of Object.entries(weights)) {
        if (weight === 0) continue;
        
        const ratesKey = field + suffix;
        const rateArray = rates[ratesKey] || rates[field];
        
        if (!rateArray || rateArray.length === 0) continue;
        
        const bucketIdx = getForecastBucketIndex(day, field);
        const rate = rateArray[bucketIdx] || 0;
        const normalizedRate = Math.min(rate / 2, 1);
        
        totalScore += normalizedRate * weight;
        maxPossible += weight;
    }
    
    if (maxPossible === 0) return 1;
    return Math.max(1, Math.round((totalScore / maxPossible) * 100));
}

function createPredictionChart() {
    if (forecastDays.length === 0 || dashboardPhotos.length === 0) {
        document.getElementById('chart_prediction').innerHTML = 
            '<div class="d-flex align-items-center justify-content-center h-100 text-muted"><span>Loading prediction data...</span></div>';
        return;
    }
    
    // Filter for buck and doe only
    const deerPhotos = dashboardPhotos.filter(p => p.animalType === 'buck' || p.animalType === 'doe');
    const rates = calculateHistoricalActivityRates('all', deerPhotos);
    
    const categories = forecastDays.map(d => {
        const date = new Date(d.datetime + 'T12:00:00');
        return Highcharts.dateFormat('%a %m/%d', date);
    });
    
    const morningScores = forecastDays.map(d => calculateActivityScore(d, rates, 'morning'));
    const eveningScores = forecastDays.map(d => calculateActivityScore(d, rates, 'evening'));
    
    // Calculate best day based on total score (morning + evening)
    const totalScores = morningScores.map((m, idx) => m + eveningScores[idx]);
    const bestDayIdx = totalScores.indexOf(Math.max(...totalScores));
    
    // Colors
    const morningFill = '#F4D03F';
    const eveningFill = '#5D6D7E';
    const borderColor = '#2d2d2d'; // Match chart background
    
    // Build 7 stacked series for morning and 7 for evening
    // Each block worth 100/7  14.29
    const series = [];
    const blockHeight = 100 / 7;
    
    for (let block = 0; block < 7; block++) {
        // Morning block
        series.push({
            name: block === 0 ? 'Morning' : undefined,
            linkedTo: block === 0 ? undefined : 'morning',
            id: block === 0 ? 'morning' : undefined,
            stack: 'morning',
            showInLegend: block === 0,
            color: morningFill,
            data: morningScores.map((score, idx) => {
                const filledBlocks = Math.round(score * 7 / 100);
                const isFilled = block < filledBlocks;
                return isFilled ? { y: blockHeight, color: morningFill } : null;
            }),
            borderWidth: 3,
            borderColor: borderColor,
            borderRadius: 3
        });
        
        // Evening block
        series.push({
            name: block === 0 ? 'Evening' : undefined,
            linkedTo: block === 0 ? undefined : 'evening',
            id: block === 0 ? 'evening' : undefined,
            stack: 'evening',
            showInLegend: block === 0,
            color: eveningFill,
            data: eveningScores.map((score, idx) => {
                const filledBlocks = Math.round(score * 7 / 100);
                const isFilled = block < filledBlocks;
                return isFilled ? { y: blockHeight, color: eveningFill } : null;
            }),
            borderWidth: 3,
            borderColor: borderColor,
            borderRadius: 3
        });
    }
    
    Highcharts.chart('chart_prediction', {
        chart: {
            type: 'column',
            backgroundColor: 'transparent',
            height: 300
        },
        accessibility: { enabled: false },
        
        title: { 
            text: 'Activity Prediction',
            style: { color: '#E0E0E3' }
        },
        
        xAxis: {
            categories: categories,
            labels: { 
                style: { color: '#E0E0E3' },
                formatter: function() {
                    if (this.pos === bestDayIdx) {
                        return '<span style="color: #F4D03F; font-weight: bold;">' + this.value + '</span>';
                    }
                    return this.value;
                },
                useHTML: true
            },
            lineColor: '#555',
            tickColor: '#555'
        },
        
        yAxis: {
            min: 0,
            max: 100,
            gridLineWidth: 0,
            labels: { enabled: false },
            title: { text: null },
            reversedStacks: false,
            plotLines: [{
                value: 100,
                color: '#555',
                width: 1,
                zIndex: 3
            }]
        },
        
        legend: {
            enabled: true,
            itemStyle: { color: '#E0E0E3' },
            itemHoverStyle: { color: '#fff' }
        },
        
        tooltip: {
            shared: true,
            backgroundColor: 'rgba(40, 40, 40, 0.95)',
            style: { color: '#E0E0E3' },
            useHTML: true,
            positioner: function(labelWidth, labelHeight, point) {
                let x = point.plotX + this.chart.plotLeft + 15;
                let y = point.plotY + this.chart.plotTop - labelHeight - 10;
                
                // Keep tooltip from going above chart
                if (y < 0) y = 10;
                
                // Keep tooltip from going past right edge
                if (x + labelWidth > this.chart.chartWidth) {
                    x = point.plotX + this.chart.plotLeft - labelWidth - 15;
                }
                
                return { x: x, y: y };
            },
            formatter: function() {
                const idx = this.points[0].point.index;
                const day = forecastDays[idx];
                const date = new Date(day.datetime + 'T12:00:00');
                const dateStr = Highcharts.dateFormat('%a, %b. %e', date);
                const star = idx === bestDayIdx ? ' ' : '';
                let html = `<b>${dateStr}${star}</b><br/>`;
                html += `<span style="color:#F4D03F">Temp:</span> ${Math.round(day.tempmin)} - ${Math.round(day.tempmax)}F<br/>`;
                html += `<span style="color:#AF7AC5">Press:</span> ${day.pressure} inHg<br/>`;
                html += `<span style="color:#7FB3D5">Wind:</span> ${getWindDirection(day.winddir)} at ${Math.round(day.windspeed)}mph<br/>`;
                html += `<span style="color:#D4AC0D">Moon:</span> ${getMoonSymbol(day.moonphase)} ${getMoonPhaseName(day.moonphase)}`;
                return html;
            }
        },
        
        plotOptions: {
            column: {
                stacking: 'normal',
                groupPadding: 0.1,
                pointPadding: 0.02,
                borderRadius: 2
            }
        },
        
        series: series,
        
        credits: { enabled: false }
    });
}

function updatePredictionChart() {
    createPredictionChart();
    updateOptimalConditions();
}

function updateOptimalConditions() {
    // Filter for buck and doe only
    const deerPhotos = dashboardPhotos.filter(p => p.animalType === 'buck' || p.animalType === 'doe');
    const rates = calculateHistoricalActivityRates('all', deerPhotos);
    
    if (rates.total === 0) {
        document.getElementById('optimalConditions').innerHTML = 
            '<span class="text-muted">No historical data available</span>';
        return;
    }
    
    // Pressure: best bucket, show as range of 0.10 inHg
    const pressureLabels = ['<29.50', '29.50', '29.55', '29.60', '29.65', '29.70', '29.75', '29.80', '29.85', '29.90', '29.95', '30.00', '30.05', '30.10', '30.15', '30.20', '30.25', '30.30', '30.35', '30.40', '30.45', '30.50'];
    const bestPressureIdx = rates.pressure.indexOf(Math.max(...rates.pressure));
    const pressureBase = 29.50 + (bestPressureIdx * 0.05);
    const pressureRange = `${pressureBase.toFixed(2)}-${(pressureBase + 0.10).toFixed(2)}`;
    
    // Temperature: best bucket, show as range of 10F
    const tempRanges = [[0, 20], [20, 30], [30, 40], [40, 50], [50, 60], [60, 70], [70, 80], [80, 90], [90, 100]];
    const bestTempIdx = rates.temp.indexOf(Math.max(...rates.temp));
    const tempRange = `${tempRanges[bestTempIdx][0]}-${tempRanges[bestTempIdx][1]}F`;
    
    // Wind Direction
    const windDirLabels = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
    const bestWindDir = rates.windDir.indexOf(Math.max(...rates.windDir));
    
    // Wind Speed
    const windSpeedLabels = ['0-3', '3-6', '6-9', '9-12', '12-15', '15+'];
    const bestWindSpeed = rates.windSpeed.indexOf(Math.max(...rates.windSpeed));
    
    // Moon Phase
    const moonLabels = [' New', ' Wax Cres', ' 1st Qtr', ' Wax Gib', ' Full', ' Wan Gib', ' 3rd Qtr', ' Wan Cres'];
    const bestMoon = rates.moonPhase.indexOf(Math.max(...rates.moonPhase));
    
    document.getElementById('optimalConditions').innerHTML = `
        <span><span style="color: #F4D03F;">Temp:</span> ${tempRange}</span>
        <span><span style="color: #AF7AC5;">Press:</span> ${pressureRange}</span>
        <span><span style="color: #7FB3D5;">Wind:</span> ${windDirLabels[bestWindDir]} at ${windSpeedLabels[bestWindSpeed]}mph</span>
        <span><span style="color: #D4AC0D;">Moon:</span> ${moonLabels[bestMoon]}</span>
    `;
}

function updateTooltipPanel(point) {
    // Debug: log point structure
    console.log('Tooltip point:', point);
    console.log('point.photoUrl:', point.photoUrl);
    console.log('point.options:', point.options);
    
    // Skip non-data series (night shading)
    // Custom properties may be on point or point.options depending on how data was set
    const camera = point.camera || point.options?.camera;
    if (!camera) return;
    
    const photoUrl = point.photoUrl || point.options?.photoUrl;
    const location = point.location || point.options?.location;
    const label = point.label || point.options?.label;
    const windSpeed = point.windSpeed ?? point.options?.windSpeed;
    const windDirection = point.windDirection ?? point.options?.windDirection;
    
    console.log('Resolved photoUrl:', photoUrl);
    
    let html = '';
    if (photoUrl) {
        html += `<img src="${photoUrl}" alt="Trail cam photo" />`;
    }
    
    // Line 1: Location | Camera
    html += `<div class="info-line">`;
    if (location) {
        html += `<span class="info-label">Location:</span> <span class="info-value">${location}</span>`;
        html += `<span class="info-sep">|</span>`;
    }
    html += `<span class="info-label">Camera:</span> <span class="info-value">${camera}</span>`;
    html += `</div>`;
    
    // Line 2: Date | Time | Wind | Gallery
    html += `<div class="info-line">`;
    html += `<span class="info-label">Date:</span> <span class="info-value">${Highcharts.dateFormat('%b %d', point.x)}</span>`;
    html += `<span class="info-sep">|</span>`;
    html += `<span class="info-label">Time:</span> <span class="info-value">${Highcharts.dateFormat('%l:%M %P', point.y)}</span>`;
    if (windSpeed !== '' && windSpeed !== undefined && windDirection !== '' && windDirection !== undefined) {
        html += `<span class="info-sep">|</span>`;
        html += `<span class="info-label">Wind:</span> <span class="info-value">${getWindDirection(windDirection)} at ${windSpeed}mph</span>`;
    }
    if (label) {
        html += `<span class="info-sep">|</span>`;
        html += `<span class="info-label">Gallery:</span> <span class="info-name">${label}</span>`;
    }
    html += `</div>`;
    
    document.getElementById('tooltipPanel').innerHTML = html;
}

// ============== ACCOUNT ==============
function togglePasswordVisibility(inputId, btn) {
    const input = document.getElementById(inputId);
    const icon = btn.querySelector('i');
    if (input.type === 'password') {
        input.type = 'text';
        icon.classList.remove('bi-eye');
        icon.classList.add('bi-eye-slash');
    } else {
        input.type = 'password';
        icon.classList.remove('bi-eye-slash');
        icon.classList.add('bi-eye');
    }
}

function loadAccountSettings() {
    // Load saved Reveal credentials
    const savedEmail = localStorage.getItem('trailcam_email');
    if (savedEmail && savedEmail !== 'QuickView') {
        document.getElementById('revealEmail').value = savedEmail;
    }
    
    // Update status based on current token
    if (accessToken) {
        document.getElementById('revealStatus').textContent = 'Connected';
        document.getElementById('revealStatus').className = 'badge bg-success';
    } else {
        document.getElementById('revealStatus').textContent = 'Not Connected';
        document.getElementById('revealStatus').className = 'badge bg-secondary';
    }
    
    // Update cache info
    updateCacheInfo();
}

async function updateCacheInfo() {
    try {
        const db = await initDB();
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.get(LOCAL_CACHE_KEY);
        
        request.onsuccess = () => {
            const data = request.result;
            if (data && data.photos) {
                document.getElementById('cacheInfo').textContent = `${data.photos.length} photos cached locally`;
            } else {
                document.getElementById('cacheInfo').textContent = 'No cache data';
            }
        };
        
        request.onerror = () => {
            document.getElementById('cacheInfo').textContent = 'Cache not available';
        };
    } catch (e) {
        document.getElementById('cacheInfo').textContent = 'Cache not available';
    }
}

async function testRevealConnection() {
    const email = document.getElementById('revealEmail').value;
    const password = document.getElementById('revealPassword').value;
    
    if (!email || !password) {
        alert('Please enter both email and password');
        return;
    }
    
    showLoading('Testing connection...');
    
    try {
        const authResponse = await fetch(CONFIG.cognitoUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-amz-json-1.1', 'X-Amz-Target': 'AWSCognitoIdentityProviderService.InitiateAuth' },
            body: JSON.stringify({
                AuthFlow: 'USER_PASSWORD_AUTH',
                ClientId: CONFIG.cognitoClientId,
                AuthParameters: { USERNAME: email, PASSWORD: password }
            })
        });
        
        const authData = await authResponse.json();
        
        if (authData.AuthenticationResult) {
            document.getElementById('revealStatus').textContent = 'Connected';
            document.getElementById('revealStatus').className = 'badge bg-success';
            hideLoading();
            alert(' Connection successful!');
        } else {
            throw new Error(authData.message || 'Authentication failed');
        }
    } catch (e) {
        document.getElementById('revealStatus').textContent = 'Failed';
        document.getElementById('revealStatus').className = 'badge bg-danger';
        hideLoading();
        alert(' Connection failed: ' + e.message);
    }
}

async function saveRevealCredentials() {
    const email = document.getElementById('revealEmail').value;
    const password = document.getElementById('revealPassword').value;
    
    if (!email || !password) {
        alert('Please enter both email and password');
        return;
    }
    
    // Test connection first
    showLoading('Verifying credentials...');
    
    try {
        const authResponse = await fetch(CONFIG.cognitoUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-amz-json-1.1', 'X-Amz-Target': 'AWSCognitoIdentityProviderService.InitiateAuth' },
            body: JSON.stringify({
                AuthFlow: 'USER_PASSWORD_AUTH',
                ClientId: CONFIG.cognitoClientId,
                AuthParameters: { USERNAME: email, PASSWORD: password }
            })
        });
        
        const authData = await authResponse.json();
        
        if (authData.AuthenticationResult) {
            // Save to localStorage
            localStorage.setItem('trailcam_email', email);
            localStorage.setItem('trailcam_token', authData.AuthenticationResult.AccessToken);
            
            // Update global token
            accessToken = authData.AuthenticationResult.AccessToken;
            
            document.getElementById('revealStatus').textContent = 'Connected';
            document.getElementById('revealStatus').className = 'badge bg-success';
            document.getElementById('userName').textContent = email.split('@')[0];
            
            hideLoading();
            alert(' Credentials saved successfully!');
        } else {
            throw new Error(authData.message || 'Authentication failed');
        }
    } catch (e) {
        document.getElementById('revealStatus').textContent = 'Failed';
        document.getElementById('revealStatus').className = 'badge bg-danger';
        hideLoading();
        alert(' Could not verify credentials: ' + e.message);
    }
}

async function clearLocalCache() {
    if (!confirm('Clear all cached photos? You will need to reload from the cloud.')) return;
    
    showLoading('Clearing cache...');
    try {
        const db = await initDB();
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        
        await new Promise((resolve, reject) => {
            const request = store.delete(LOCAL_CACHE_KEY);
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
        
        allPhotos = [];
        filteredPhotos = [];
        applyFilters();
        updateCacheInfo();
        hideLoading();
        alert('Cache cleared. Use "Fetch New" to reload photos.');
    } catch (e) {
        hideLoading();
        alert('Error clearing cache: ' + e.message);
    }
}

// ============== KEYBOARD ==============
document.addEventListener('keydown', e => {
    // Quick Tag Zoom Modal navigation
    if (zoomModalOpen) {
        if (e.key === 'Escape') { closeZoomModal(); return; }
        if (e.key === 'ArrowLeft') { zoomPrev(); return; }
        if (e.key === 'ArrowRight' || e.key === ' ') { e.preventDefault(); zoomNext(); return; }
    }
});

// ============== INIT ==============
// No auto-session check - just show login screen
</script>

</body>
</html>
